<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PHP 连接数据库</title>
    <link href="undefined2019/09/17/PHP%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>2019/09/17/PHP%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="PHP-是这世界上最好的语言"><a href="#PHP-是这世界上最好的语言" class="headerlink" title="PHP 是这世界上最好的语言"></a>PHP 是这世界上最好的语言</h3><a id="more"></a><pre><code class="php">    $server_name = &#39;localhost:3306&#39;;    $dbms_username = &#39;root&#39;;    $dbms_password = &#39;&#39;;    $db_name = &#39;jingdongdong&#39;;    $conn = new mysqli($server_name, $dbms_username, $dbms_password, $db_name);    if($conn-&gt;connect_error) {        echo &quot;连接失败。&quot;;        return;    }else{        echo &quot;连接成功&quot;;    }</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>php mysql 数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM</title>
    <link href="undefined2019/08/06/DOM/"/>
    <url>2019/08/06/DOM/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML-DOM-简介"><a href="#HTML-DOM-简介" class="headerlink" title="HTML DOM 简介"></a>HTML DOM 简介</h1><h2 id="什么是HTML-DOM"><a href="#什么是HTML-DOM" class="headerlink" title="什么是HTML DOM?"></a>什么是HTML DOM?</h2><p>DOM是W3C的标准 , 它定义了访问 HTML 和 XML 文档的标准 , HTML DOM 则是专门适用于 HTML / XHTML 的文档对象模型   </p><a id="more"></a><p>它定义了访问和操作 HTML 文档的标准方法 , 并将 HTML 文档呈现为带有元素 , 属性与文本的树状结构 </p><p>HTML DOM 独立于平台和编程语言 , 它可被任何编程语言 , 如 Java , JavaScript 和 VBScript 使用</p><h3 id="HTML-DOM-是"><a href="#HTML-DOM-是" class="headerlink" title="HTML DOM 是"></a>HTML DOM 是</h3><ul><li>HTML 的标准对象模型</li><li>HTML 的标准API</li><li>W3C 标准</li></ul><h2 id="DOM-的功能"><a href="#DOM-的功能" class="headerlink" title="DOM 的功能"></a>DOM 的功能</h2><ul><li>查询某个元素</li><li>查询某个元素的祖先、兄弟以及后代元素</li><li>获取、修改元素的属性</li><li>获取、修改元素的内容</li><li>创建、插入和删除元素</li></ul><p>简而言之 , DOM 为页面中的实时数据交互提供了可能性 , JavaScript 通过 DOM 可以访问并操作 HTML 文档中的内容</p><h1 id="DOM-节点"><a href="#DOM-节点" class="headerlink" title="DOM 节点"></a>DOM 节点</h1><h2 id="DOM-节点分类"><a href="#DOM-节点分类" class="headerlink" title="DOM 节点分类"></a>DOM 节点分类</h2><ul><li>整个文档是一个文档节点</li><li>每个 HTML 元素是一个元素节点</li><li>元素内的文本是一个文本节点</li><li>每个元素属性是一个属性节点</li><li>注释为注释节点</li></ul><blockquote><p>HTML DOM 节点树</p></blockquote><img src="https://s2.ax1x.com/2019/08/21/mt7Kr4.gif" width="480"><p>通过 HTML DOM , JavaScript 可以访问树中的任意节点 , 所有节点均可被修改 , 也可以创建或删除节点</p><h2 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">querySelector()</td><td align="left">返回指定选择器或选择器组匹配的第一个元素</td></tr><tr><td align="left">querySelectorAll()</td><td align="left">返回指定选择器或选择器组匹配的全部元素</td></tr><tr><td align="left">getElementById()</td><td align="left">返回带有指定 ID 的元素</td></tr><tr><td align="left">getElementsByTagName()</td><td align="left">返回带有指定标签名的元素的节点列表</td></tr><tr><td align="left">getElementsByClassName()</td><td align="left">返回带有指定类名的元素的节点列表</td></tr><tr><td align="left">appendChild()</td><td align="left">把新的子节点添加到指定节点</td></tr><tr><td align="left">removeChild()</td><td align="left">删除子节点</td></tr><tr><td align="left">replaceChild()</td><td align="left">替换子节点</td></tr><tr><td align="left">insertBefore()</td><td align="left">在指定的子节点前面插入新的子节点</td></tr><tr><td align="left">createAttribute()</td><td align="left">创建属性节点</td></tr><tr><td align="left">createElement()</td><td align="left">创建元素节点</td></tr><tr><td align="left">createTextNode()</td><td align="left">创建文本节点</td></tr><tr><td align="left">getAttribute()</td><td align="left">返回指定的属性值</td></tr><tr><td align="left">setAttribute()</td><td align="left">把指定属性设置或修改为指定的值</td></tr><tr><td align="left">removeAttribute()</td><td align="left">删除指定的属性</td></tr></tbody></table><h3 id="document-querySelector-selectors"><a href="#document-querySelector-selectors" class="headerlink" title="document.querySelector(selectors)"></a>document.querySelector(selectors)</h3><p>说明 : 按照指定 CSS 选择器返回第一个匹配的元素</p><pre><code class="js">var el = document.querySelector(&quot;div.user-panel.main input[name=&#39;login&#39;]&quot;);</code></pre><p>若使用多个选择器 , 中间使用逗号隔开</p><h3 id="document-querySelectorAll-selectors"><a href="#document-querySelectorAll-selectors" class="headerlink" title="document.querySelectorAll(selectors)"></a>document.querySelectorAll(selectors)</h3><p>说明 : 按照指定CSS选择器返回全部的元素</p><p>返回值为对象集合 , 使用方法类似 querySelector()</p><h3 id="document-getElementById-id"><a href="#document-getElementById-id" class="headerlink" title="document.getElementById(id)"></a>document.getElementById(id)</h3><p>说明 : 按照指定 id 取得元素对象 , 如果 id 重复 , 则返回第一个对象</p><p>document.getElementById(id) 的返回值是一个对象 , 有 value 和 length 等属性</p><h3 id="document-getElementsByTagName-tagName"><a href="#document-getElementsByTagName-tagName" class="headerlink" title="document.getElementsByTagName(tagName)"></a>document.getElementsByTagName(tagName)</h3><p>说明 : 按照标签名取得元素节点列表</p><p>此方法的返回值是一个伪数组 , 只支持length属性 , 它是一个动态的元素节点集合 , 会根据 DOM 树的变化自动更新</p><p>如果想对getElementsByTagName()返回值调用数组方法 , 可将其转化为数组</p><p>方法如下</p><pre><code class="js">var divObjs=document.getElementsByTagName(&quot;div&quot;);// 方法一Array.prototype.slice.call(divObjs); // 方法二  此方法IE不支持Array.from(divObjs);// 方法三 : 声明一个空数组，遍历伪数组中的元素添加到空数组中。 </code></pre><h3 id="document-getElementsByClassName-className"><a href="#document-getElementsByClassName-className" class="headerlink" title="document.getElementsByClassName(className)"></a>document.getElementsByClassName(className)</h3><p>说明 : 按照指定 class 取得元素对象列表<br>其返回值形式同getElementsByTagName()</p><p>注意 , IE8以下及以下浏览器 , 不支持此方法 , 请勿使用 IE8 及以下浏览器</p><h3 id="node-appendChild-node"><a href="#node-appendChild-node" class="headerlink" title="node.appendChild(node)"></a>node.appendChild(node)</h3><p>说明 : 在节点的子节点列表末尾添加节点 , 或将一个节点的子节点移动到另一个节点下</p><p>添加子节点</p><pre><code class="html">&lt;ul id=&quot;list1&quot;&gt;    &lt;li&gt;A&lt;/li&gt;    &lt;li&gt;B&lt;/li&gt;&lt;/ul&gt;&lt;ul id=&quot;list2&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="js">var newNode=document.createElement(&quot;li&quot;);var textNode = document.createTextNode(&#39;C&#39;);newNode.appendChild(textNode);//创建节点 &lt;li&gt;C&lt;/li&gt;document.getElementById(&#39;list1&#39;).appendChild(newNode);//添加新节点到id为list的元素内</code></pre><p>移动子节点</p><pre><code class="html">&lt;ul id=&quot;list1&quot;&gt;    &lt;li&gt;A&lt;/li&gt;    &lt;li&gt;B&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;    &lt;li id=&quot;li&quot;&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="js">var li=document.getElementById(&quot;li&quot;);document.getElementById(&#39;list1&#39;).appendChild(li);//移动 id 为 &quot;li&quot; 的节点到 id 为 list 的元素内</code></pre><h3 id="node-removeChild-node"><a href="#node-removeChild-node" class="headerlink" title="node.removeChild(node)"></a>node.removeChild(node)</h3><p>说明 : 从DOM中删除子节点<br>返回值为被删除的子节点 , 该节点已从DOM树中删除 , 但仍然存在于内存中</p><h3 id="node-removeChild-child"><a href="#node-removeChild-child" class="headerlink" title="node.removeChild(child);"></a>node.removeChild(child);</h3><p>在这种情况下 , 被删除的节点很快会被内存管理回收 , 如果需要保留此节点 , 可使用如下方式</p><pre><code class="js">var nodeDel = node.removeChild(child);</code></pre><h3 id="node-replaceChild-newNode-oldNode"><a href="#node-replaceChild-newNode-oldNode" class="headerlink" title="node.replaceChild(newNode, oldNode)"></a>node.replaceChild(newNode, oldNode)</h3><p>说明 : 将某个节点替换为另一个 , 原节点会被从 DOM 树中删除<br>返回值为原节点 (oldchild)</p><h3 id="node-insertBefore-newNode-existingnode"><a href="#node-insertBefore-newNode-existingnode" class="headerlink" title="node.insertBefore(newNode, existingnode)"></a>node.insertBefore(newNode, existingnode)</h3><p>说明 : 将一个节点插入到另一个节点前<br>返回值为新插入的节点 (newNode)</p><p>与 appendChild() 的作用有一定相似<br>insertBefore() 在节点前插入节点 , 相对于兄弟节点<br>appendChild() 在末尾插入节点 , 相对于父级节点</p><h3 id="document-createAttribute-attribute"><a href="#document-createAttribute-attribute" class="headerlink" title="document.createAttribute(attribute)"></a>document.createAttribute(attribute)</h3><p>说明 : 创建一个指定名称的属性节点<br>参数为属性名 , 返回值为 Attr 对象属性 , 此方法仅能创建一条属性 , 并不会设置具体属性值</p><p>设置属性值方法如下 </p><pre><code class="html">&lt;p&gt;test&lt;/p&gt;</code></pre><pre><code class="js">var attr = document.createAttribute(&quot;style&quot;);attr.nodeValue = &quot;color: #f06&quot;;var p=document.getElementsByTagName(&#39;p&#39;)[0];  p.setAttributeNode(attr);   </code></pre><p>效果如下   </p><pre><code class="html">&lt;p style=&quot;color: #f06&quot;&gt;test&lt;/p&gt;</code></pre><p>注  </p><p>setAttribute() 方法与 createAttribute() 方法作用类似 , 但可以直接添加属性及属性值 , 使用更简便</p><pre><code class="js">element.setAttribute(attributename,attributevalue)  </code></pre><h3 id="document-createElement-tagName"><a href="#document-createElement-tagName" class="headerlink" title="document.createElement(tagName)"></a>document.createElement(tagName)</h3><p>说明 : 创建一个元素节点 , 即一个HTML元素<br>返回值为新创建的元素 , 与 appendChild() 或 insertBefore() 方法搭配使用 , 以在任意位置插入一个新建节点</p><pre><code class="js">var btn = document.createElement(&quot;input&quot;);btn.type = &quot;button&quot;;btn.value = &quot;新建按钮&quot;;</code></pre><h3 id="document-createTextNode-data"><a href="#document-createTextNode-data" class="headerlink" title="document.createTextNode(data)"></a>document.createTextNode(data)</h3><p>说明 : 创建一个文本节点<br>返回值为此文本节点对象 , 文本节点中的内容均为文本 , 无论其格式如何<br>例如</p><pre><code class="js">var text = document.createTextNode(&quot;&lt;div&gt;Hello&lt;/div&gt;&quot;);</code></pre><p>在浏览器中会显示 <code>&lt;div&gt;Hello&lt;/div&gt;</code>本身 , 而不会显示一个内容为 “ Hello” 的 div</p><h3 id="node-getAttribute-data"><a href="#node-getAttribute-data" class="headerlink" title="node.getAttribute(data)"></a>node.getAttribute(data)</h3><p>说明 : 取得某一节点的某一属性值<br>返回此属性的属性值 , 是一个字符串</p><pre><code class="js">var node = document.getElementById(&#39;node&#39;);console.log(node.getAttribute(&#39;name&#39;));node.setAttribute(data)</code></pre><p>说明 : 添加指定的属性 , 并为其赋指定的值<br>返回指定属性的属性值 , 如果这个指定的属性已存在 , 则仅设置 / 更改值</p><pre><code class="js">var node = document.getElementById(&#39;node&#39;);node.setAttribute(&#39;name&#39;, &#39;thisIsTheNode&#39;);node.removeAttribute(data)</code></pre><p>说明 : 删除指定的属性<br>返回被删除的属性 , 此方法不支持 IE 浏览器</p><pre><code class="js">var node = document.getElementById(&#39;node&#39;);node.removeAttribute(&#39;name&#39;);</code></pre><h1 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h1><h2 id="nodeName-nodeValue-nodeType"><a href="#nodeName-nodeValue-nodeType" class="headerlink" title="nodeName, nodeValue, nodeType"></a>nodeName, nodeValue, nodeType</h2><p>这三个属性的值取决于节点的类型</p><h3 id="nodeName-节点名称"><a href="#nodeName-节点名称" class="headerlink" title="nodeName 节点名称"></a>nodeName 节点名称</h3><ul><li>元素节点的 nodeName 是标签名称 (大写)</li><li>属性节点的 nodeName 是属性名称</li><li>文本节点的 nodeName 永远是 #text</li><li>文档节点的 nodeName 永远是 #document</li></ul><pre><code class="js">console.log(document.nodeName); //#documentconsole.log(element.nodeName);  //DIVconsole.log(attr.nodeName);     //idconsole.log(text.nodeName);     //#text</code></pre><h3 id="nodeValue-节点值"><a href="#nodeValue-节点值" class="headerlink" title="nodeValue 节点值"></a>nodeValue 节点值</h3><ul><li>对于文本节点，nodeValue 属性包含文本。</li><li>对于属性节点，nodeValue 属性包含属性值。</li><li>文档节点和元素节点，nodeValue 属性的值始</li></ul><h3 id="nodeType-节点类型"><a href="#nodeType-节点类型" class="headerlink" title="nodeType 节点类型"></a>nodeType 节点类型</h3><table><thead><tr><th align="left">常量名</th><th align="left">常量值</th><th align="left">节点类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Node.ELEMENT_NODE</td><td align="left">1</td><td align="left">Element</td><td align="left">代表元素节点</td></tr><tr><td align="left">Node.ATTRIBUTE_NODE</td><td align="left">2</td><td align="left">Attr</td><td align="left">代表属性节点</td></tr><tr><td align="left">Node.TEXT_NODE</td><td align="left">3</td><td align="left">Text</td><td align="left">代表文本节点</td></tr><tr><td align="left">Node.COMMENT_NODE</td><td align="left">8</td><td align="left">Comment</td><td align="left">代表注释节点</td></tr><tr><td align="left">Node.DOCUMENT_NODE</td><td align="left">9</td><td align="left">Document</td><td align="left">代表整个文档</td></tr></tbody></table><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><h3 id="textContent-innerText-innerHTML"><a href="#textContent-innerText-innerHTML" class="headerlink" title="textContent / innerText / innerHTML"></a>textContent / innerText / innerHTML</h3><pre><code class="html">&lt;div id=&quot;element&quot;&gt;    &lt;p&gt;Test text&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="js">var element = document.getElementById(&#39;element&#39;)console.log(element.innerHTML)  //    &lt;p&gt;Test text&lt;/p&gt;console.log(element.innerText)  //Test textconsole.log(element.textContent)//    Test text   </code></pre><p>innerHTML : 获取节点内的元素与文本 , 以 string 类型存储<br>innerText : 获取节点内的文本 ( 不包括空白字符 )<br>textContent : 获取节点内的文本 ( 包括空白字符 )   </p><h3 id="parentNode-parentElement-父节点-父元素"><a href="#parentNode-parentElement-父节点-父元素" class="headerlink" title="parentNode / parentElement 父节点 / 父元素"></a>parentNode / parentElement 父节点 / 父元素</h3><p>取得某一节点的父节点 / 取得某一节点的父元素<br>一般情况下 , 这两种属性的值是相等的 , 特例为根节点 document , document 属于节点 , 但不是元素节点 , 此时 parentNode 的值为#document , 但 parentElement 的值为 null</p><h3 id="previousSibling-previousElementChild-前一个兄弟节点-前一个兄弟元素"><a href="#previousSibling-previousElementChild-前一个兄弟节点-前一个兄弟元素" class="headerlink" title="previousSibling / previousElementChild 前一个兄弟节点 / 前一个兄弟元素"></a>previousSibling / previousElementChild 前一个兄弟节点 / 前一个兄弟元素</h3><p>previousSibling 不仅能够返回子元素(ElementNode) , 还可能取得文本节点(TextNode) , 谨慎使用<br>IE8以下浏览器中 previousSibling 会取得前一个兄弟元素 , 且不支持previousElementChild    </p><h3 id="nextSibling-nextElementChild-下一个兄弟节点-下一个兄弟元素"><a href="#nextSibling-nextElementChild-下一个兄弟节点-下一个兄弟元素" class="headerlink" title="nextSibling / nextElementChild 下一个兄弟节点 / 下一个兄弟元素"></a>nextSibling / nextElementChild 下一个兄弟节点 / 下一个兄弟元素</h3><p>使用方法 , 特性及兼容性与 previousSibling / previousElementChild 相似    </p><h3 id="childNodes-children-子节点集合-子元素集合"><a href="#childNodes-children-子节点集合-子元素集合" class="headerlink" title="childNodes / children 子节点集合 / 子元素集合"></a>childNodes / children 子节点集合 / 子元素集合</h3><p>同 firstChild / firstElementChild , childNodes 能够取得文本节点 , 但 children 只会取得元素节点<br>在 firefox 与 chrome 等主流浏览器中 , 会将 空格 / 制表符 / 换行 等空白字符解析为空的文本节点 , 在使用 childNodes 时 , 需要注意这些空白字符     </p><h3 id="firstChild-firstElementChild-首个子节点-首个子元素"><a href="#firstChild-firstElementChild-首个子节点-首个子元素" class="headerlink" title="firstChild / firstElementChild 首个子节点 / 首个子元素"></a>firstChild / firstElementChild 首个子节点 / 首个子元素</h3><p>取得某一节点的第一个子节点 / 取得某一节点的第一个子元素<br>firstChild 不仅能够取得子元素(ElementNode) , 还能取得文本节点(TextNode) , 谨慎使用     </p><p>可使用 firstElementChild 获取节点的第一个元素节点</p><p>发现有如下写法 , 原发布者认为可以使用这种方法避免firstChild取得文本节点 , 而得到元素节点</p><pre><code class="js">firstChild(element);//ReferenceError: firstChild is not defined</code></pre><p>Firfox 与 Chrome 测试时报错 , 方法不可行</p><p>兼容性 : IE8 以下浏览器中 firstChild 会取得第一个元素节点 , firstElementChild 不兼容</p><h3 id="lastChild-lastElementChild-最后一个子节点-最后一个子元素"><a href="#lastChild-lastElementChild-最后一个子节点-最后一个子元素" class="headerlink" title="lastChild / lastElementChild 最后一个子节点 / 最后一个子元素"></a>lastChild / lastElementChild 最后一个子节点 / 最后一个子元素</h3><p>使用方法与特性与 firstChild / firstElementChild 相似<br>兼容性 : IE8 以下浏览器 lastChild 会取得最后一个元素节点 , 不支持lastElementChild   </p><h1 id="HTML-DOM-事件-Event"><a href="#HTML-DOM-事件-Event" class="headerlink" title="HTML DOM 事件 (Event)"></a>HTML DOM 事件 (Event)</h1><h2 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h2><ul><li>事件源 触发事件的对象</li><li>事件类型 如何触发事件</li><li>事件处理程序 通过函数的方式处理<pre><code class="js">element.onclick = function(){Alert(&#39;Clicked&#39;);}</code></pre></li></ul><h2 id="事件流-EventFlow"><a href="#事件流-EventFlow" class="headerlink" title="事件流 (EventFlow)"></a>事件流 (EventFlow)</h2><h3 id="事件发生的过程"><a href="#事件发生的过程" class="headerlink" title="事件发生的过程"></a>事件发生的过程</h3><p>在事件触发时，页面元素接受触发事件的顺序，被称为事件流，在事件流的定义上，微软 ( IE ) 与网景 (Netscape) 提出了完全相反的观点</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>当事件发生时，触发事件元素的外侧节点先获得信息，目标节点应该最后接收到事件，是一个由外向里的过程，Netscape 支持此观点</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>当事件发生时，整个事件流从从里向外的，由目标节点接收，逐层向上级节点传递，IE 支持此观点    </p><p>这样的分歧造成了浏览器兼容性的差异<br>为缓解分歧，W3C定义了DOM事件流，即    </p><p>先事件捕获，到达具体目标，再事件排序    </p><p>在这个过程中，每一个相关节点都会收到两次事件</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="DOM-0"><a href="#DOM-0" class="headerlink" title="DOM 0"></a>DOM 0</h3><p>在DOM标准定义之前的阶段，称作 DOM 0 阶段<br>DOM 0 的事件处理程序有以下特点</p><ul><li>只能处理冒泡阶段的事件</li><li>同一个元素的同一个事件，重复绑定会覆盖</li><li>this 指向 on 之前的元素</li><li>兼容性好 ( 兼容 IE )</li></ul><h4 id="绑定-DOM-0-事件"><a href="#绑定-DOM-0-事件" class="headerlink" title="绑定 DOM 0 事件"></a>绑定 DOM 0 事件</h4><pre><code class="html">&lt;body&gt;    &lt;div&gt;        &lt;button&gt;BTN&lt;/button&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><pre><code class="js">var btn = document.querySelector(&#39;button&#39;);var div = document.querySelector(&#39;div&#39;);var bdy = document.querySelector(&#39;body&#39;);btn.onclick = function(){    console.log(this.tagName)}div.onclick = function(){    console.log(this.tagName)}bdy.onclick = function(){    console.log(this.tagName)}//点击Button , 控制台输出如下//BUTTON//DIV//BODY    </code></pre><p>可见 , DOM 0 的事件处理程序并没有处理捕获阶段的事件</p><h4 id="清除-DOM-0-事件"><a href="#清除-DOM-0-事件" class="headerlink" title="清除 DOM 0 事件"></a>清除 DOM 0 事件</h4><pre><code class="js">btn.onclick = null;</code></pre><h3 id="DOM-2"><a href="#DOM-2" class="headerlink" title="DOM 2"></a>DOM 2</h3><p>相对 DOM 0 , DOM 2 可以多次绑定同一事件 , 即同一事件再次绑定不会覆盖 , 而按照绑定顺序先后执行   </p><h4 id="绑定-DOM-2-事件"><a href="#绑定-DOM-2-事件" class="headerlink" title="绑定 DOM 2 事件"></a>绑定 DOM 2 事件</h4><pre><code class="js">element.addEventListener(&#39;click&#39;, func, false);</code></pre><p>第一个参数为事件句柄<br>第二个参数指定事件处理函数<br>第三个参数指定事件在捕获阶段还是冒泡阶段执行 , true 为捕获阶段 , false 为冒泡阶段    </p><h4 id="清除-DOM-2-事件"><a href="#清除-DOM-2-事件" class="headerlink" title="清除 DOM 2 事件"></a>清除 DOM 2 事件</h4><pre><code class="js">element.removeEventListener(&quot;click&quot;, func);</code></pre><p>要清除 DOM 2 事件 , 在绑定事件时使用的事件处理函数必须为外部函数 , 如果该函数为匿名函数 , 该事件是无法清除的  </p><h2 id="事件对象-Event"><a href="#事件对象-Event" class="headerlink" title="事件对象 (Event)"></a>事件对象 (Event)</h2><p>事件对象中存放着与发生的事件相关联的信息 , 如光标位置 , 键盘按下的键值     </p><h3 id="取得事件对象的方法"><a href="#取得事件对象的方法" class="headerlink" title="取得事件对象的方法"></a>取得事件对象的方法</h3><ul><li>事件处理函数的参数</li><li>window.event </li></ul><pre><code class="js">window.onclick = function(evt) {    var e = evt || window.event;    //如果 evt 有值，则取用 evt 的值，否则使用window.event的值    //处理 IE8 以下浏览器兼容性问题}</code></pre><h3 id="事件对象相关属性与方法"><a href="#事件对象相关属性与方法" class="headerlink" title="事件对象相关属性与方法"></a>事件对象相关属性与方法</h3><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">event.type</td><td align="left">触发的事件类型</td></tr><tr><td align="left">event.target</td><td align="left">事件的目标元素</td></tr><tr><td align="left">evt.clintX</td><td align="left">点击位置相对浏览器边界的 X 坐标</td></tr><tr><td align="left">evt.clintY</td><td align="left">点击位置相对浏览器边界的 Y 坐标</td></tr><tr><td align="left">evt.pageX</td><td align="left">点击位置相对页面边界的 X 坐标</td></tr><tr><td align="left">evt.pageY</td><td align="left">点击位置相对页面边界的 Y 坐标</td></tr><tr><td align="left">evt.offsetX</td><td align="left">相对于带有定位的父盒子的 X 坐标</td></tr><tr><td align="left">evt.offsetY</td><td align="left">相对于带有定位的父盒子的 Y 坐标</td></tr><tr><td align="left">evt.screenX</td><td align="left">点击位置相对显示器边界的 X 坐标</td></tr><tr><td align="left">evt.screenY</td><td align="left">点击位置相对显示器边界的 Y 坐标</td></tr><tr><td align="left">evt.keycode</td><td align="left">键盘按下键的键值</td></tr><tr><td align="left">event.preventDefault()</td><td align="left">阻止事件的默认动作</td></tr><tr><td align="left">event.stopPropagation()</td><td align="left">停止事件传播</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>DOM JS EVENT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Array</title>
    <link href="undefined2019/07/21/Array/"/>
    <url>2019/07/21/Array/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数组是一组数据的集合 , 在一个数组中 , 数组元素可以是任何类型 , 在内存中是一段连续的内存空间   </p><a id="more"></a><p>每个元素在数组中占据一个位置 , 称为索引 , 索引从 0 开始 , 最大值为数组长度减 1</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ul><li><p>直接创建</p><pre><code class="js">  var arrA = [];//空数组  var arrB = [1,2,3]//三个值的数组  var arrC = [1,&#39;string&#39;, Object, true,]//有不同类型数据的数组 , 最后一个逗号为结尾的逗号  //结尾的逗号可以去掉 , 在主流浏览器中可兼容（IE8 以下浏览器未测试）</code></pre></li><li><p>构造函数创建</p><pre><code class="js">  var arrD = new Array();//空数组  var arrE = new Array(5);//[empty × 5]  var arrF = new Array(1,2,3,4,5);//[1,2,3,4,5]</code></pre></li></ul><h2 id="遍历-迭代"><a href="#遍历-迭代" class="headerlink" title="遍历 / 迭代"></a>遍历 / 迭代</h2><pre><code class="js">var arr = new Array(1,2,3,4,5)for(var i in arr){    console.log(arr[i]);}</code></pre><p>以上的for in循环等价于</p><pre><code class="js">for(var i = 0 ; i &lt; arr.length ; i++){    console.log(arr[i]);}</code></pre><h1 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h1><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">concat()</td><td align="left">连接两个或更多的数组 , 并返回结果</td></tr><tr><td align="left">join()</td><td align="left">把所有数组元素放入一个字符串 , 元素通过指定的分隔符进行分隔</td></tr><tr><td align="left">reverse()</td><td align="left">反转数组中元素的顺序</td></tr><tr><td align="left">slice()</td><td align="left">从某个已有的数组返回选定的元素</td></tr><tr><td align="left">splice()</td><td align="left">删除元素 , 并向数组添加新元素</td></tr><tr><td align="left">indexOf()</td><td align="left">查找元素在数组中的位置</td></tr><tr><td align="left">lastIndexOf()</td><td align="left">从后向前开始查找元素在数组中的位置</td></tr><tr><td align="left">pop()</td><td align="left">删除并返回数组的最后一个元素</td></tr><tr><td align="left">push()</td><td align="left">向数组的末尾添加一个或更多元素</td></tr><tr><td align="left">shift()</td><td align="left">删除并返回数组的第一个元素</td></tr><tr><td align="left">unshift()</td><td align="left">向数组的开头添加一个或更多元素</td></tr><tr><td align="left">valueOf()</td><td align="left">返回数组对象的原始值</td></tr><tr><td align="left">sort()</td><td align="left">对数组的元素进行排序</td></tr><tr><td align="left">toString()</td><td align="left">把数组转换为字符串 , 并返回结果</td></tr><tr><td align="left">toLocaleString()</td><td align="left">把数组转换为本地数组 , 并返回结果</td></tr><tr><td align="left">map()</td><td align="left">将数组中的每个元素调用一个提供的函数 , 原数组不变</td></tr><tr><td align="left">forEach()</td><td align="left">将数组中的每个元素执行传进提供的函数 , 原数组改变</td></tr><tr><td align="left">filter()</td><td align="left">对所有元素进行判断 , 将满足条件的元素作为一个新的数组返回</td></tr><tr><td align="left">every()</td><td align="left">将所有元素进行判断 , 所有元素都满足判断条件 , 则返回true</td></tr><tr><td align="left">some()</td><td align="left">将所有元素进行判断 , 存在元素都满足判断条件 , 则返回true</td></tr></tbody></table><h2 id="arrayObject-concat-array1-array2-……-arrayN"><a href="#arrayObject-concat-array1-array2-……-arrayN" class="headerlink" title="arrayObject.concat(array1, array2, …… , arrayN)"></a>arrayObject.concat(array1, array2, …… , arrayN)</h2><p>将数组进行连接 , 返回连接后的新数组 , 不改变原数组</p><pre><code class="js">var arrA = new Array(1, 2, 3);console.log(arrA.concat(4, 5));//[1, 2, 3, 4, 5]var arrB = new Array(1, 2);var arrC = new Array(3, 4);var arrD = new Array(5, 6);var arr = arrB.concat(arrC, arrD)console.log(arr);//[1, 2, 3, 4, 5, 6]</code></pre><h2 id="arrayObject-join-separator"><a href="#arrayObject-join-separator" class="headerlink" title="arrayObject.join(separator)"></a>arrayObject.join(separator)</h2><p>将数组中的所有元素放入一个字符串 , 元素之间用指定的分隔符分隔<br>参数 separator (分隔符) 可选 , 如参数缺省 , 默认使用逗号作为分隔府<br>不改变原数组</p><pre><code class="js">var arrE = [a, b, c];console.log(arrE.join());//a-b-c</code></pre><p>注 : String.split() 与 join() 的功能相反 , 将字符串按照指定的分隔符切割为数组 , 搭配使用 , 可实现反转字符串功能</p><pre><code class="js">var info = &quot;Hello!&quot;info.split(&#39;&#39;);//分隔符为空字符串console.log(info);//[&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]info = info.reverse().join(&#39;&#39;);console.log(info);//olleH</code></pre><h2 id="arrayObject-reverse"><a href="#arrayObject-reverse" class="headerlink" title="arrayObject.reverse()"></a>arrayObject.reverse()</h2><p>将数组中全部元素顺序反转 , 此方法改变原数组</p><h2 id="arrayObject-slice-startIndex-endIndex"><a href="#arrayObject-slice-startIndex-endIndex" class="headerlink" title="arrayObject.slice(startIndex, endIndex)"></a>arrayObject.slice(startIndex, endIndex)</h2><p>将数组中指定索引之间的元素截取 , 存储至一个新数组中 , 返回新数组<br>不改变原数组  </p><p>startIndex : 开始截取位置<br>endIndex : 结束截取位置   </p><p>截取元素索引从startIndex所在元素开始 , 包括此元素 , 截取至endIndex所在元素为止 , 不包括第二个参数所指向的元素   </p><pre><code class="js">var arr = new Array(1,2,3,4,5,6,7,8,9);console.log(arr.slice(2,6));//3,4,5,6</code></pre><p>特点</p><ul><li>如果不传入参数 , slice() 会截取整个数组 , 相当于将数组复制了一次</li><li>如果只传入一个参数 , 会从此参数所指的元素开始 , 截取至最后一个元素 ( 包括最后一个元素 )</li><li>如果参数为负值 , 代表倒数第几个 , 此时参数不再等同于元素索引 , 如 -1 指倒数第一个元素</li><li>如果第一个参数所在位置在第二个参数之后 , 返回空数组   </li></ul><h2 id="arrayObject-splice-start-deleteCount-item1-item2-item3…"><a href="#arrayObject-splice-start-deleteCount-item1-item2-item3…" class="headerlink" title="arrayObject.splice(start, deleteCount, item1, item2, item3…)"></a>arrayObject.splice(start, deleteCount, item1, item2, item3…)</h2><p>在指定位置对数组进行编辑 , 改变原数组<br>返回被删除的元素组成的新数组 , 如果未删除元素 , 返回空数组</p><p>start : 开始操作的位置<br>deleteCount : 删除元素的个数 , 如果不删除 , 传入 0<br>item1, item2… : 在操作位置插入的元素   </p><h2 id="arrayObject-indexOf-item-start"><a href="#arrayObject-indexOf-item-start" class="headerlink" title="arrayObject.indexOf(item, start)"></a>arrayObject.indexOf(item, start)</h2><p>查找指定元素在数组中的索引 , 找到了返回索引 , 未找到返回 -1</p><p>item : 要查找的元素的元素值<br>start : 开始查找的位置 ( 索引值 )<br>arrayObject.lastIndexOf(item, start)    </p><p>功能与 indexOf() 相似 , 但从数组后向前查找    </p><p>注 两种方法查找方式均为按元素值查找 , 在有重复元素的数组中 , 返回值可能并不相同</p><h2 id="arrayObject-push-item1-item2-item3……"><a href="#arrayObject-push-item1-item2-item3……" class="headerlink" title="arrayObject.push(item1, item2, item3……)"></a>arrayObject.push(item1, item2, item3……)</h2><p>将元素放在数组的最后面 , 返回值为新数组长度 , 改变原数组</p><h2 id="arrayObject-pop"><a href="#arrayObject-pop" class="headerlink" title="arrayObject.pop()"></a>arrayObject.pop()</h2><p>将数组的最后一个元素删除 , 返回被删除元素的值 , 原数组改变</p><h2 id="arrayObject-unshift-item1-item2-item3……"><a href="#arrayObject-unshift-item1-item2-item3……" class="headerlink" title="arrayObject.unshift(item1, item2, item3……)"></a>arrayObject.unshift(item1, item2, item3……)</h2><p>将元素插入到数组的开头 , 返回值为新数组长度 , 改变原数组</p><h2 id="arrayObject-shift"><a href="#arrayObject-shift" class="headerlink" title="arrayObject.shift()"></a>arrayObject.shift()</h2><p>将数组开头的元素删除 , 返回被删除元素的值 , 原数组改变</p><h2 id="arrayObject-valueOf"><a href="#arrayObject-valueOf" class="headerlink" title="arrayObject.valueOf()"></a>arrayObject.valueOf()</h2><p>返回数组元素本身 (Object)</p><h2 id="arrayObject-sort-function"><a href="#arrayObject-sort-function" class="headerlink" title="arrayObject.sort(function)"></a>arrayObject.sort(function)</h2><p>对数组元素进行排序，改变原数组，返回对数组的引用</p><p>不带参数调用 sort() 时，排序后的结果并不按照数值大小排列，而是以字母表顺序 ( ACSII码顺序 ) 进行排序 ( 如有必要将临时转化为字符串 )<br>当带参数调用 sort() 时，会按照参数 ( function类型 ) 中设定的排序方式进行排序</p><p>以下是对 sort() 的基本分析</p><pre><code class="js">function mySort(func){    if(func == undefined){//无参数情况下，比较ASCII码        for(var i=0;i&lt;theArray.length;i++){            for(var j=0;j&lt;theArray.length-i;j++){                var temp;                if(theArray[j]&gt;theArray[j+1]){                    temp = theArray[j];                    theArray[j] = theArray[j+1];                    theArray[j+1] = temp;                }            }        }    }    else if(typeof func == &#39;function&#39;){        for(var i=0;i&lt;theArray.length-1;i++){            for(var j=0;j&lt;theArray.length-i-1;j++){                var temp;                var decide = func(theArray[j], theArray[j+1]);                if(decide&gt;0){                    //按照传入参数的返回值执行排序                    //返回值大于 0，说明array[j]&gt;array[j+1]                    //此时交换元素值                    temp = theArray[j];                    theArray[j] = theArray[j+1];                    theArray[j+1] = temp;                }            }        }    }    return theArray;}</code></pre><p>一个简单的排序函数</p><pre><code class="js">arr.sort(function(a,b){    return a-b;});arrayObject.toString()返回表示函数源代码的字符串var arr = [1,6,4,2,8,&quot;asd&quot;,true,,,&quot;aszxs&quot;]console.log(arr.toString())//1,6,4,2,8,asd,true,,,aszxs</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型转换</title>
    <link href="undefined2019/07/11/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>2019/07/11/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h1><p>不同类型的变量比较要先转类型, 通常发生在运算符加减乘除, 等于, 还有大于, 小于等   </p><a id="more"></a><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul><li><p>字符串加数字, 数字就会转成字符串</p></li><li><p>数字减字符串, 字符串转成数字, 反之亦然<br>  如果字符串不是纯数字, 就会返回 NaN<br>  乘, 除, 大于, 小于的转换也是一样</p></li><li><p>字符串和数字比较时，字符串转数字</p></li><li><p>数字为布尔比较时，布尔转数字</p></li><li><p>字符串和布尔比较时，两者转数字</p></li><li><p>undefined等于null</p></li></ul><p>例如  </p><pre><code class="js">console.log(10+&#39;20&#39;) //2010 Stringconsole.log(10-&#39;20&#39;)//-10 numberconsole.log(10-&#39;one&#39;) //NaNconsole.log(10-&#39;101a&#39;) //NaNconsole.log(10*&#39;20&#39;) //200 numberconsole.log(&#39;10&#39;*&#39;20&#39;) //200 numberconsole.log(20/&#39;10&#39;) //2 numberconsole.log(&#39;20&#39;/&#39;10&#39;) //2 numberconsole.log(&#39;20&#39;/&#39;one&#39;) //NaNconsole.log(&#39;0&#39;==0) //trueconsole.log(0==false) //trueconsole.log(&#39;0&#39;==false) //trueconsole.log(null==false) //falseconsole.log(undefined==false) //falseconsole.log(undefined==null) //true</code></pre><h1 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h1><pre><code class="js">parseInt() &amp; parseFloat()parseInt(&quot;1234blue&quot;);   //returns 1234parseInt(&quot;0xA&quot;);        //returns 10parseInt(&quot;  22.5&quot;);     //returns 22parseInt(&quot;22   5&quot;);     //returns 22parseInt(&quot;blue&quot;);       //returns NaNparseFloat(&quot;1234blue&quot;); //returns 1234.0parseFloat(&quot;0xA&quot;);      //returns NaNparseFloat(&quot;  22.5  &quot;); //returns 22.5parseFloat(&quot;22.34.5&quot;);  //returns 22.34parseFloat(&quot;0908&quot;);     //returns 908parseFloat(&quot;blue&quot;);     //returns NaN</code></pre><p>parse 意为 “解析”<br>parseInt() 将值转换成整数, parseFloat() 将值转换成浮点数</p><p>这两个函数只能对 String 类型使用,其他类型会返回 NaN  </p><pre><code class="js">parseInt(&quot;AF&quot;, 16);     //returns 175parseInt(&quot;10&quot;, 2);      //returns 2parseInt(&quot;10&quot;, 8);      //returns 8parseInt(&quot;10&quot;, 10);     //returns 10   </code></pre><p>parsrInt() 可以进行进制转换, 将16进制, 8进制, 2进制或其他进制的字符串转换为整数, 进制由方法的第二个参数指定</p><pre><code class="js">parseInt(&quot;010&quot;);        //returns 8parseInt(&quot;010&quot;, 8);     //returns 8parseInt(&quot;010&quot;, 10);    //returns 10</code></pre><p>如果十进制数包含前导0, 那么最好指明第二个参数为10, 这样才不会意外地得到八进制的值</p><h2 id="window-Number"><a href="#window-Number" class="headerlink" title="window.Number()"></a>window.Number()</h2><p>可以将任意类型的参数mix转换为数值类型  </p><p>如果是布尔值, true和false分别被转换为1和0</p><p>如果是数字值, 返回本身<br>如果是null, 返回0<br>如果是undefined, 返回NaN<br>如果是字符串, 遵循以下规则  </p><ul><li>如果字符串中只包含数字, 则将其转换为十进制 ( 忽略前导 0 )</li><li>如果字符串中包含有效的浮点格式, 将其转换为浮点数值 ( 忽略前导 0 )</li><li>如果是空字符串, 返回 0</li><li>如果字符串中无以上格式, 则将其转换为NaN</li><li>如果是对象, 则调用对象的valueOf()方法, 然后依据前面的规则转换返回的值。如果转换的结果是NaN, 则调用对象的toString()方法, 再次依照前面的规则转换返回的字符串值   </li></ul><pre><code class="js">Number(null)         //0Number(undefined)    //NaNNumber(true)         //1Number(false)        //0Number(&quot;  123 456  &quot;)//NaNNumber(&quot;  123456   &quot;)//123456Number(&quot;  123.456  &quot;)//123.456Number(&quot;  123.45.6 &quot;)//NaN</code></pre><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>除undefined和null之外的所有类型的值都具有toString()方法, 其作用是返回对象的字符串表示</p><table><thead><tr><th align="left">对象</th><th align="left">操作</th></tr></thead><tbody><tr><td align="left">Array</td><td align="left">将 Array 的元素转换为字符串 , 结果字符串由逗号分隔, 且连接起来</td></tr><tr><td align="left">Boolean</td><td align="left">如果 Boolean 值是 true, 则返回 “true” , 否则返回 “false”</td></tr><tr><td align="left">Date</td><td align="left">返回日期的文字表示法</td></tr><tr><td align="left">Error</td><td align="left">返回一个包含相关错误信息的字符串</td></tr><tr><td align="left">Function</td><td align="left">返回如下格式的字符串 : function func() { [native code] }</td></tr><tr><td align="left">Number</td><td align="left">返回数字的文字表示</td></tr><tr><td align="left">String</td><td align="left">返回 String 对象的值</td></tr><tr><td align="left">默认</td><td align="left">返回 “ [ object obj ] ”</td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h2><p>将任何类型的值转换为字符串</p><ul><li>如果有toString()方法, 则调用该方法 ( 不传递radix参数 ) 并返回结果</li><li>如果是null, 返回”null”</li><li>如果是undefined, 返回”undefined”  </li></ul><h2 id="window-Boolean"><a href="#window-Boolean" class="headerlink" title="window.Boolean()"></a>window.Boolean()</h2><p>将任何类型的值转换为布尔值  </p><p>以下值会被转换为false</p><pre><code class="js">window.Boolean(false);      //falsewindow.Boolean(&quot;&quot;);         //falsewindow.Boolean(0);          //falsewindow.Boolean(NaN);        //falsewindow.Boolean(null);       //falsewindow.Boolean(undefined);  //false</code></pre><p>其余所有值都会返回 true</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端布局</title>
    <link href="undefined2019/06/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/"/>
    <url>2019/06/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一-弹性布局-百分比布局-流式布局-——拉勾网、天猫首页"><a href="#一-弹性布局-百分比布局-流式布局-——拉勾网、天猫首页" class="headerlink" title="一 弹性布局 ( 百分比布局, 流式布局 ) ——拉勾网、天猫首页"></a>一 弹性布局 ( 百分比布局, 流式布局 ) ——拉勾网、天猫首页</h1><p>优点 : 充分发挥大手机的优势——显示内容更多   </p><p>缺点 : 屏幕过大会造成元素间距过大, 比例失调</p><p>特点 : </p><a id="more"></a><p>顶部与底部的bar不管分辨率怎么变, 它的高度和位置都不变<br>例如 , 中间每条招聘信息不管分辨率怎么变 , 招聘公司的图标等信息都位于条目的左边 , 薪资都位于右边   </p><p>如何识别手机尺寸 通过设置meta语句 : </p><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;</code></pre><p>在网页的中增加这句话 , 可以让网页的宽度自动适应手机屏幕的宽度</p><p>也可以写成 : </p><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot; /&gt;  </code></pre><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">width</td><td align="left">可视区域的宽度</td></tr><tr><td align="left">height</td><td align="left">可视区域的高度</td></tr><tr><td align="left">device-width</td><td align="left">设备屏幕的宽度</td></tr><tr><td align="left">initial-scale</td><td align="left">页面首次被显示时的缩放级别 ( 0-10.0 ) , 取值为1时页面按实际尺寸显示, 无任何缩放</td></tr><tr><td align="left">minimum-scale</td><td align="left">设定最小缩小比例 ( 0-10.0 ) , 取值为1时将禁止用户缩小至实际尺寸之下</td></tr><tr><td align="left">maximum-scale</td><td align="left">设定最大放大比例 ( 0-10.0 ) , 取值为1时将禁止用户放大至实际尺寸之上</td></tr><tr><td align="left">user-scalable</td><td align="left">设定用户是否可以缩放 ( yes/no )</td></tr></tbody></table><h2 id="viewport的概念"><a href="#viewport的概念" class="headerlink" title="viewport的概念"></a>viewport的概念</h2><p>移动设备上的 viewport 就是设备的屏幕上能用来显示我们的网页的那一块区域, 但 viewport 又不局限于浏览器可视区域的大小 , 它可能比浏览器的可视区域要大 , 也可能比浏览器的可视区域要小   </p><p>在默认情况下 , 一般来讲 , 移动设备上的 viewport 都是要大于浏览器可视区域的 , 这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小 , 所以为了能在移动设备上正常显示那些传统的、为桌面浏览器设计的网站 , 移动设备上的浏览器都会把自己默认的 viewport 设为 980px 或 1024px ( 也可能是其它值 , 这个是由设备自己决定的 ) , 但带来的后果就是浏览器会出现横向滚动条 , 因为浏览器可视区域的宽度比这个默认的 viewport 的宽度要小</p><h2 id="关于像素"><a href="#关于像素" class="headerlink" title="关于像素"></a>关于像素</h2><p>在css中, 我们一般使用px作为单位, 在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素, 这可能会造成我们的一个错觉, 那就是css中的像素就是设备的物理像. 但实际情况却并非如此, css中的像素只是一个抽象的单位, 在不同的设备或不同的环境中, css中的1px所代表的设备物理像素是不同的. 在为桌面浏览器设计的网页中, 我们无需对这个斤斤计较, 但在移动设备上, 必须弄明白这点   </p><p>在早先的移动设备中, 屏幕像素密度都比较低, 如iphone3, 它的分辨率为320x480, 在iphone3上, 一个css像素确实是等于一个屏幕物理像素的. 后来随着技术的发展, 移动设备的屏幕像素密度越来越高, 从iphone4开始, 苹果公司便推出了所谓的Retina屏, 分辨率提高了一倍, 变成640x960, 但屏幕尺寸却没变化, 这就意味着同样大小的屏幕上, 像素却多了一倍, 这时, 一个css像素是等于两个物理像素的  </p><p>注 :<br>devicePixelRatio 设备像素比 (DPR)</p><p>Retina屏 —–视网膜屏幕</p><h1 id="二-等比缩放布局-rem布局-——网易、淘宝首页"><a href="#二-等比缩放布局-rem布局-——网易、淘宝首页" class="headerlink" title="二 等比缩放布局 ( rem布局 ) ——网易、淘宝首页"></a>二 等比缩放布局 ( rem布局 ) ——网易、淘宝首页</h1><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>视口(viewport)设置</p><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1, minimum-scale=1&quot;&gt;</code></pre><p>在html上根据不同分辨率设置不同 font-size</p><p>页面里除了 font-size 之外的其它 css 尺寸都使用了 rem 作为单位</p><p>正文的 font-size 需要额外的媒介查询, 并且不使用 rem</p><p>例如   </p><pre><code class="css">@media screen and (max-width: 320px) {body{    font-size: 12px;  }}@media screen and (min-width:320px) and (max-width: 375px) {body{    font-size: 14px;  }}@media screen and (min-width: 375px) and (max-width: 414px) {body{    font-size: 16px;  }}@media screen and (min-width: 414px) {body{    font-size: 18px;  }}</code></pre><h1 id="VW"><a href="#VW" class="headerlink" title="VW"></a>VW</h1><p>vw是可视区宽度单位 1vw等于可视区宽度的百分之一</p><p>100vw = 可视窗口宽度</p><p>100vh = 可视窗口高度</p><p>1vw = 1% 视口宽 ( viewport ) </p><p>在 iPhone6 中根字号等于100px的时候, 视口宽等于375</p><p>html— font-size : 100 px</p><p>在 iPhone6 中根字号 100px , 1vw = 3.75 px , 然后将 px 单位转换为 vw , 让其随着视口变化而变化</p><p>1vw == 3.75 px<br>？ vw == 100 px</p><p>26.67 vw 等于 100px 所以就将 HTML 的字号设置为 26.67vw , 这样HTML的字号就会随着视口变化而变化了</p><p>在rem布局里 , 文字不推荐转换为rem , 可以使用媒体查询</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS 移动端 REM 布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>