<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DOM</title>
    <link href="undefined2019/09/17/DOM/"/>
    <url>2019/09/17/DOM/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML-DOM-简介"><a href="#HTML-DOM-简介" class="headerlink" title="HTML DOM 简介"></a>HTML DOM 简介</h1><h2 id="什么是HTML-DOM"><a href="#什么是HTML-DOM" class="headerlink" title="什么是HTML DOM?"></a>什么是HTML DOM?</h2><p>DOM是W3C的标准 , 它定义了访问 HTML 和 XML 文档的标准 , HTML DOM 则是专门适用于 HTML / XHTML 的文档对象模型 , 它定义了访问和操作 HTML 文档的标准方法 , 并将 HTML 文档呈现为带有元素 , 属性与文本的树状结构 </p><a id="more"></a><p>HTML DOM 独立于平台和编程语言 , 它可被任何编程语言 , 如 Java , JavaScript 和 VBScript 使用</p><h3 id="HTML-DOM-是"><a href="#HTML-DOM-是" class="headerlink" title="HTML DOM 是"></a>HTML DOM 是</h3><ul><li>HTML 的标准对象模型</li><li>HTML 的标准API</li><li>W3C 标准</li></ul><h2 id="DOM-的功能"><a href="#DOM-的功能" class="headerlink" title="DOM 的功能"></a>DOM 的功能</h2><ul><li>查询某个元素</li><li>查询某个元素的祖先、兄弟以及后代元素</li><li>获取、修改元素的属性</li><li>获取、修改元素的内容</li><li>创建、插入和删除元素</li></ul><p>简而言之 , DOM 为页面中的实时数据交互提供了可能性 , JavaScript 通过 DOM 可以访问并操作 HTML 文档中的内容</p><h1 id="DOM-节点"><a href="#DOM-节点" class="headerlink" title="DOM 节点"></a>DOM 节点</h1><h2 id="DOM-节点分类"><a href="#DOM-节点分类" class="headerlink" title="DOM 节点分类"></a>DOM 节点分类</h2><ul><li>整个文档是一个文档节点</li><li>每个 HTML 元素是一个元素节点</li><li>元素内的文本是一个文本节点</li><li>每个元素属性是一个属性节点</li><li>注释为注释节点</li></ul><blockquote><p>HTML DOM 节点树</p></blockquote><img src="https://s2.ax1x.com/2019/08/21/mt7Kr4.gif" width="480"><p>通过 HTML DOM , JavaScript 可以访问树中的任意节点 , 所有节点均可被修改 , 也可以创建或删除节点</p><h2 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">querySelector()</td><td align="left">返回指定选择器或选择器组匹配的第一个元素</td></tr><tr><td align="left">querySelectorAll()</td><td align="left">返回指定选择器或选择器组匹配的全部元素</td></tr><tr><td align="left">getElementById()</td><td align="left">返回带有指定 ID 的元素</td></tr><tr><td align="left">getElementsByTagName()</td><td align="left">返回带有指定标签名的元素的节点列表</td></tr><tr><td align="left">getElementsByClassName()</td><td align="left">返回带有指定类名的元素的节点列表</td></tr><tr><td align="left">appendChild()</td><td align="left">把新的子节点添加到指定节点</td></tr><tr><td align="left">removeChild()</td><td align="left">删除子节点</td></tr><tr><td align="left">replaceChild()</td><td align="left">替换子节点</td></tr><tr><td align="left">insertBefore()</td><td align="left">在指定的子节点前面插入新的子节点</td></tr><tr><td align="left">createAttribute()</td><td align="left">创建属性节点</td></tr><tr><td align="left">createElement()</td><td align="left">创建元素节点</td></tr><tr><td align="left">createTextNode()</td><td align="left">创建文本节点</td></tr><tr><td align="left">getAttribute()</td><td align="left">返回指定的属性值</td></tr><tr><td align="left">setAttribute()</td><td align="left">把指定属性设置或修改为指定的值</td></tr><tr><td align="left">removeAttribute()</td><td align="left">删除指定的属性</td></tr></tbody></table><h3 id="document-querySelector-selectors"><a href="#document-querySelector-selectors" class="headerlink" title="document.querySelector(selectors)"></a>document.querySelector(selectors)</h3><p>说明 : 按照指定 CSS 选择器返回第一个匹配的元素</p><pre><code class="js">var el = document.querySelector(&quot;div.user-panel.main input[name=&#39;login&#39;]&quot;);</code></pre><p>若使用多个选择器 , 中间使用逗号隔开</p><h3 id="document-querySelectorAll-selectors"><a href="#document-querySelectorAll-selectors" class="headerlink" title="document.querySelectorAll(selectors)"></a>document.querySelectorAll(selectors)</h3><p>说明 : 按照指定CSS选择器返回全部的元素</p><p>返回值为对象集合 , 使用方法类似 querySelector()</p><h3 id="document-getElementById-id"><a href="#document-getElementById-id" class="headerlink" title="document.getElementById(id)"></a>document.getElementById(id)</h3><p>说明 : 按照指定 id 取得元素对象 , 如果 id 重复 , 则返回第一个对象</p><p>document.getElementById(id) 的返回值是一个对象 , 有 value 和 length 等属性</p><h3 id="document-getElementsByTagName-tagName"><a href="#document-getElementsByTagName-tagName" class="headerlink" title="document.getElementsByTagName(tagName)"></a>document.getElementsByTagName(tagName)</h3><p>说明 : 按照标签名取得元素节点列表</p><p>此方法的返回值是一个伪数组 , 只支持length属性 , 它是一个动态的元素节点集合 , 会根据 DOM 树的变化自动更新</p><p>如果想对getElementsByTagName()返回值调用数组方法 , 可将其转化为数组</p><p>方法如下</p><pre><code class="js">var divObjs=document.getElementsByTagName(&quot;div&quot;);// 方法一Array.prototype.slice.call(divObjs); // 方法二  此方法IE不支持Array.from(divObjs);// 方法三 : 声明一个空数组，遍历伪数组中的元素添加到空数组中。 </code></pre><h3 id="document-getElementsByClassName-className"><a href="#document-getElementsByClassName-className" class="headerlink" title="document.getElementsByClassName(className)"></a>document.getElementsByClassName(className)</h3><p>说明 : 按照指定 class 取得元素对象列表<br>其返回值形式同getElementsByTagName()</p><p>注意 , IE8以下及以下浏览器 , 不支持此方法 , 请勿使用 IE8 及以下浏览器</p><h3 id="node-appendChild-node"><a href="#node-appendChild-node" class="headerlink" title="node.appendChild(node)"></a>node.appendChild(node)</h3><p>说明 : 在节点的子节点列表末尾添加节点 , 或将一个节点的子节点移动到另一个节点下</p><p>添加子节点</p><pre><code class="html">&lt;ul id=&quot;list1&quot;&gt;    &lt;li&gt;A&lt;/li&gt;    &lt;li&gt;B&lt;/li&gt;&lt;/ul&gt;&lt;ul id=&quot;list2&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="js">var newNode=document.createElement(&quot;li&quot;);var textNode = document.createTextNode(&#39;C&#39;);newNode.appendChild(textNode);//创建节点 &lt;li&gt;C&lt;/li&gt;document.getElementById(&#39;list1&#39;).appendChild(newNode);//添加新节点到id为list的元素内</code></pre><p>移动子节点</p><pre><code class="html">&lt;ul id=&quot;list1&quot;&gt;    &lt;li&gt;A&lt;/li&gt;    &lt;li&gt;B&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;    &lt;li id=&quot;li&quot;&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="js">var li=document.getElementById(&quot;li&quot;);document.getElementById(&#39;list1&#39;).appendChild(li);//移动 id 为 &quot;li&quot; 的节点到 id 为 list 的元素内</code></pre><h3 id="node-removeChild-node"><a href="#node-removeChild-node" class="headerlink" title="node.removeChild(node)"></a>node.removeChild(node)</h3><p>说明 : 从DOM中删除子节点<br>返回值为被删除的子节点 , 该节点已从DOM树中删除 , 但仍然存在于内存中</p><h3 id="node-removeChild-child"><a href="#node-removeChild-child" class="headerlink" title="node.removeChild(child);"></a>node.removeChild(child);</h3><p>在这种情况下 , 被删除的节点很快会被内存管理回收 , 如果需要保留此节点 , 可使用如下方式</p><pre><code class="js">var nodeDel = node.removeChild(child);</code></pre><h3 id="node-replaceChild-newNode-oldNode"><a href="#node-replaceChild-newNode-oldNode" class="headerlink" title="node.replaceChild(newNode, oldNode)"></a>node.replaceChild(newNode, oldNode)</h3><p>说明 : 将某个节点替换为另一个 , 原节点会被从 DOM 树中删除<br>返回值为原节点 (oldchild)</p><h3 id="node-insertBefore-newNode-existingnode"><a href="#node-insertBefore-newNode-existingnode" class="headerlink" title="node.insertBefore(newNode, existingnode)"></a>node.insertBefore(newNode, existingnode)</h3><p>说明 : 将一个节点插入到另一个节点前<br>返回值为新插入的节点 (newNode)</p><p>与 appendChild() 的作用有一定相似<br>insertBefore() 在节点前插入节点 , 相对于兄弟节点<br>appendChild() 在末尾插入节点 , 相对于父级节点</p><h3 id="document-createAttribute-attribute"><a href="#document-createAttribute-attribute" class="headerlink" title="document.createAttribute(attribute)"></a>document.createAttribute(attribute)</h3><p>说明 : 创建一个指定名称的属性节点<br>参数为属性名 , 返回值为 Attr 对象属性 , 此方法仅能创建一条属性 , 并不会设置具体属性值</p><p>设置属性值方法如下 </p><pre><code class="html">&lt;p&gt;test&lt;/p&gt;</code></pre><pre><code class="js">var attr = document.createAttribute(&quot;style&quot;);attr.nodeValue = &quot;color: #f06&quot;;var p=document.getElementsByTagName(&#39;p&#39;)[0];  p.setAttributeNode(attr);   </code></pre><p>效果如下   </p><pre><code class="html">&lt;p style=&quot;color: #f06&quot;&gt;test&lt;/p&gt;</code></pre><p>注  </p><p>setAttribute() 方法与 createAttribute() 方法作用类似 , 但可以直接添加属性及属性值 , 使用更简便</p><pre><code class="js">element.setAttribute(attributename,attributevalue)  </code></pre><h3 id="document-createElement-tagName"><a href="#document-createElement-tagName" class="headerlink" title="document.createElement(tagName)"></a>document.createElement(tagName)</h3><p>说明 : 创建一个元素节点 , 即一个HTML元素<br>返回值为新创建的元素 , 与 appendChild() 或 insertBefore() 方法搭配使用 , 以在任意位置插入一个新建节点</p><pre><code class="js">var btn = document.createElement(&quot;input&quot;);btn.type = &quot;button&quot;;btn.value = &quot;新建按钮&quot;;</code></pre><h3 id="document-createTextNode-data"><a href="#document-createTextNode-data" class="headerlink" title="document.createTextNode(data)"></a>document.createTextNode(data)</h3><p>说明 : 创建一个文本节点<br>返回值为此文本节点对象 , 文本节点中的内容均为文本 , 无论其格式如何<br>例如</p><pre><code class="js">var text = document.createTextNode(&quot;&lt;div&gt;Hello&lt;/div&gt;&quot;);</code></pre><p>在浏览器中会显示 <code>&lt;div&gt;Hello&lt;/div&gt;</code>本身 , 而不会显示一个内容为 “ Hello” 的 div</p><h3 id="node-getAttribute-data"><a href="#node-getAttribute-data" class="headerlink" title="node.getAttribute(data)"></a>node.getAttribute(data)</h3><p>说明 : 取得某一节点的某一属性值<br>返回此属性的属性值 , 是一个字符串</p><pre><code class="js">var node = document.getElementById(&#39;node&#39;);console.log(node.getAttribute(&#39;name&#39;));node.setAttribute(data)</code></pre><p>说明 : 添加指定的属性 , 并为其赋指定的值<br>返回指定属性的属性值 , 如果这个指定的属性已存在 , 则仅设置 / 更改值</p><pre><code class="js">var node = document.getElementById(&#39;node&#39;);node.setAttribute(&#39;name&#39;, &#39;thisIsTheNode&#39;);node.removeAttribute(data)</code></pre><p>说明 : 删除指定的属性<br>返回被删除的属性 , 此方法不支持 IE 浏览器</p><pre><code class="js">var node = document.getElementById(&#39;node&#39;);node.removeAttribute(&#39;name&#39;);</code></pre><h1 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h1><h2 id="nodeName-nodeValue-nodeType"><a href="#nodeName-nodeValue-nodeType" class="headerlink" title="nodeName, nodeValue, nodeType"></a>nodeName, nodeValue, nodeType</h2><p>这三个属性的值取决于节点的类型</p><h3 id="nodeName-节点名称"><a href="#nodeName-节点名称" class="headerlink" title="nodeName 节点名称"></a>nodeName 节点名称</h3><ul><li>元素节点的 nodeName 是标签名称 (大写)</li><li>属性节点的 nodeName 是属性名称</li><li>文本节点的 nodeName 永远是 #text</li><li>文档节点的 nodeName 永远是 #document</li></ul><pre><code class="js">console.log(document.nodeName); //#documentconsole.log(element.nodeName);  //DIVconsole.log(attr.nodeName);     //idconsole.log(text.nodeName);     //#text</code></pre><h3 id="nodeValue-节点值"><a href="#nodeValue-节点值" class="headerlink" title="nodeValue 节点值"></a>nodeValue 节点值</h3><ul><li>对于文本节点，nodeValue 属性包含文本。</li><li>对于属性节点，nodeValue 属性包含属性值。</li><li>文档节点和元素节点，nodeValue 属性的值始</li></ul><h3 id="nodeType-节点类型"><a href="#nodeType-节点类型" class="headerlink" title="nodeType 节点类型"></a>nodeType 节点类型</h3><table><thead><tr><th align="left">常量名</th><th align="left">常量值</th><th align="left">节点类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Node.ELEMENT_NODE</td><td align="left">1</td><td align="left">Element</td><td align="left">代表元素节点</td></tr><tr><td align="left">Node.ATTRIBUTE_NODE</td><td align="left">2</td><td align="left">Attr</td><td align="left">代表属性节点</td></tr><tr><td align="left">Node.TEXT_NODE</td><td align="left">3</td><td align="left">Text</td><td align="left">代表文本节点</td></tr><tr><td align="left">Node.COMMENT_NODE</td><td align="left">8</td><td align="left">Comment</td><td align="left">代表注释节点</td></tr><tr><td align="left">Node.DOCUMENT_NODE</td><td align="left">9</td><td align="left">Document</td><td align="left">代表整个文档</td></tr></tbody></table><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><h3 id="textContent-innerText-innerHTML"><a href="#textContent-innerText-innerHTML" class="headerlink" title="textContent / innerText / innerHTML"></a>textContent / innerText / innerHTML</h3><pre><code class="html">&lt;div id=&quot;element&quot;&gt;    &lt;p&gt;Test text&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="js">var element = document.getElementById(&#39;element&#39;)console.log(element.innerHTML)  //    &lt;p&gt;Test text&lt;/p&gt;console.log(element.innerText)  //Test textconsole.log(element.textContent)//    Test text   </code></pre><p>innerHTML : 获取节点内的元素与文本 , 以 string 类型存储<br>innerText : 获取节点内的文本 ( 不包括空白字符 )<br>textContent : 获取节点内的文本 ( 包括空白字符 )   </p><h3 id="parentNode-parentElement-父节点-父元素"><a href="#parentNode-parentElement-父节点-父元素" class="headerlink" title="parentNode / parentElement 父节点 / 父元素"></a>parentNode / parentElement 父节点 / 父元素</h3><p>取得某一节点的父节点 / 取得某一节点的父元素<br>一般情况下 , 这两种属性的值是相等的 , 特例为根节点 document , document 属于节点 , 但不是元素节点 , 此时 parentNode 的值为#document , 但 parentElement 的值为 null</p><h3 id="previousSibling-previousElementChild-前一个兄弟节点-前一个兄弟元素"><a href="#previousSibling-previousElementChild-前一个兄弟节点-前一个兄弟元素" class="headerlink" title="previousSibling / previousElementChild 前一个兄弟节点 / 前一个兄弟元素"></a>previousSibling / previousElementChild 前一个兄弟节点 / 前一个兄弟元素</h3><p>previousSibling 不仅能够返回子元素(ElementNode) , 还可能取得文本节点(TextNode) , 谨慎使用<br>IE8以下浏览器中 previousSibling 会取得前一个兄弟元素 , 且不支持previousElementChild    </p><h3 id="nextSibling-nextElementChild-下一个兄弟节点-下一个兄弟元素"><a href="#nextSibling-nextElementChild-下一个兄弟节点-下一个兄弟元素" class="headerlink" title="nextSibling / nextElementChild 下一个兄弟节点 / 下一个兄弟元素"></a>nextSibling / nextElementChild 下一个兄弟节点 / 下一个兄弟元素</h3><p>使用方法 , 特性及兼容性与 previousSibling / previousElementChild 相似    </p><h3 id="childNodes-children-子节点集合-子元素集合"><a href="#childNodes-children-子节点集合-子元素集合" class="headerlink" title="childNodes / children 子节点集合 / 子元素集合"></a>childNodes / children 子节点集合 / 子元素集合</h3><p>同 firstChild / firstElementChild , childNodes 能够取得文本节点 , 但 children 只会取得元素节点<br>在 firefox 与 chrome 等主流浏览器中 , 会将 空格 / 制表符 / 换行 等空白字符解析为空的文本节点 , 在使用 childNodes 时 , 需要注意这些空白字符     </p><h3 id="firstChild-firstElementChild-首个子节点-首个子元素"><a href="#firstChild-firstElementChild-首个子节点-首个子元素" class="headerlink" title="firstChild / firstElementChild 首个子节点 / 首个子元素"></a>firstChild / firstElementChild 首个子节点 / 首个子元素</h3><p>取得某一节点的第一个子节点 / 取得某一节点的第一个子元素<br>firstChild 不仅能够取得子元素(ElementNode) , 还能取得文本节点(TextNode) , 谨慎使用     </p><p>可使用 firstElementChild 获取节点的第一个元素节点</p><p>发现有如下写法 , 原发布者认为可以使用这种方法避免firstChild取得文本节点 , 而得到元素节点</p><pre><code class="js">firstChild(element);//ReferenceError: firstChild is not defined</code></pre><p>Firfox 与 Chrome 测试时报错 , 方法不可行</p><p>兼容性 : IE8 以下浏览器中 firstChild 会取得第一个元素节点 , firstElementChild 不兼容</p><h3 id="lastChild-lastElementChild-最后一个子节点-最后一个子元素"><a href="#lastChild-lastElementChild-最后一个子节点-最后一个子元素" class="headerlink" title="lastChild / lastElementChild 最后一个子节点 / 最后一个子元素"></a>lastChild / lastElementChild 最后一个子节点 / 最后一个子元素</h3><p>使用方法与特性与 firstChild / firstElementChild 相似<br>兼容性 : IE8 以下浏览器 lastChild 会取得最后一个元素节点 , 不支持lastElementChild   </p><h1 id="HTML-DOM-事件-Event"><a href="#HTML-DOM-事件-Event" class="headerlink" title="HTML DOM 事件 (Event)"></a>HTML DOM 事件 (Event)</h1><h2 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h2><ul><li>事件源 触发事件的对象</li><li>事件类型 如何触发事件</li><li>事件处理程序 通过函数的方式处理<pre><code class="js">element.onclick = function(){Alert(&#39;Clicked&#39;);}</code></pre></li></ul><h2 id="事件流-EventFlow"><a href="#事件流-EventFlow" class="headerlink" title="事件流 (EventFlow)"></a>事件流 (EventFlow)</h2><h3 id="事件发生的过程"><a href="#事件发生的过程" class="headerlink" title="事件发生的过程"></a>事件发生的过程</h3><p>在事件触发时，页面元素接受触发事件的顺序，被称为事件流，在事件流的定义上，微软 ( IE ) 与网景 (Netscape) 提出了完全相反的观点</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>当事件发生时，触发事件元素的外侧节点先获得信息，目标节点应该最后接收到事件，是一个由外向里的过程，Netscape 支持此观点</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>当事件发生时，整个事件流从从里向外的，由目标节点接收，逐层向上级节点传递，IE 支持此观点    </p><p>这样的分歧造成了浏览器兼容性的差异<br>为缓解分歧，W3C定义了DOM事件流，即    </p><p>先事件捕获，到达具体目标，再事件排序    </p><p>在这个过程中，每一个相关节点都会收到两次事件</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="DOM-0"><a href="#DOM-0" class="headerlink" title="DOM 0"></a>DOM 0</h3><p>在DOM标准定义之前的阶段，称作 DOM 0 阶段<br>DOM 0 的事件处理程序有以下特点</p><ul><li>只能处理冒泡阶段的事件</li><li>同一个元素的同一个事件，重复绑定会覆盖</li><li>this 指向 on 之前的元素</li><li>兼容性好 ( 兼容 IE )</li></ul><h4 id="绑定-DOM-0-事件"><a href="#绑定-DOM-0-事件" class="headerlink" title="绑定 DOM 0 事件"></a>绑定 DOM 0 事件</h4><pre><code class="html">&lt;body&gt;    &lt;div&gt;        &lt;button&gt;BTN&lt;/button&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><pre><code class="js">var btn = document.querySelector(&#39;button&#39;);var div = document.querySelector(&#39;div&#39;);var bdy = document.querySelector(&#39;body&#39;);btn.onclick = function(){    console.log(this.tagName)}div.onclick = function(){    console.log(this.tagName)}bdy.onclick = function(){    console.log(this.tagName)}//点击Button , 控制台输出如下//BUTTON//DIV//BODY    </code></pre><p>可见 , DOM 0 的事件处理程序并没有处理捕获阶段的事件</p><h4 id="清除-DOM-0-事件"><a href="#清除-DOM-0-事件" class="headerlink" title="清除 DOM 0 事件"></a>清除 DOM 0 事件</h4><pre><code class="js">btn.onclick = null;</code></pre><h3 id="DOM-2"><a href="#DOM-2" class="headerlink" title="DOM 2"></a>DOM 2</h3><p>相对 DOM 0 , DOM 2 可以多次绑定同一事件 , 即同一事件再次绑定不会覆盖 , 而按照绑定顺序先后执行   </p><h4 id="绑定-DOM-2-事件"><a href="#绑定-DOM-2-事件" class="headerlink" title="绑定 DOM 2 事件"></a>绑定 DOM 2 事件</h4><pre><code class="js">element.addEventListener(&#39;click&#39;, func, false);</code></pre><p>第一个参数为事件句柄<br>第二个参数指定事件处理函数<br>第三个参数指定事件在捕获阶段还是冒泡阶段执行 , true 为捕获阶段 , false 为冒泡阶段    </p><h4 id="清除-DOM-2-事件"><a href="#清除-DOM-2-事件" class="headerlink" title="清除 DOM 2 事件"></a>清除 DOM 2 事件</h4><pre><code class="js">element.removeEventListener(&quot;click&quot;, func);</code></pre><p>要清除 DOM 2 事件 , 在绑定事件时使用的事件处理函数必须为外部函数 , 如果该函数为匿名函数 , 该事件是无法清除的  </p><h2 id="事件对象-Event"><a href="#事件对象-Event" class="headerlink" title="事件对象 (Event)"></a>事件对象 (Event)</h2><p>事件对象中存放着与发生的事件相关联的信息 , 如光标位置 , 键盘按下的键值     </p><h3 id="取得事件对象的方法"><a href="#取得事件对象的方法" class="headerlink" title="取得事件对象的方法"></a>取得事件对象的方法</h3><ul><li>事件处理函数的参数</li><li>window.event </li></ul><pre><code class="js">window.onclick = function(evt) {    var e = evt || window.event;    //如果 evt 有值，则取用 evt 的值，否则使用window.event的值    //处理 IE8 以下浏览器兼容性问题}</code></pre><h3 id="事件对象相关属性与方法"><a href="#事件对象相关属性与方法" class="headerlink" title="事件对象相关属性与方法"></a>事件对象相关属性与方法</h3><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">event.type</td><td align="left">触发的事件类型</td></tr><tr><td align="left">event.target</td><td align="left">事件的目标元素</td></tr><tr><td align="left">evt.clintX</td><td align="left">点击位置相对浏览器边界的 X 坐标</td></tr><tr><td align="left">evt.clintY</td><td align="left">点击位置相对浏览器边界的 Y 坐标</td></tr><tr><td align="left">evt.pageX</td><td align="left">点击位置相对页面边界的 X 坐标</td></tr><tr><td align="left">evt.pageY</td><td align="left">点击位置相对页面边界的 Y 坐标</td></tr><tr><td align="left">evt.offsetX</td><td align="left">相对于带有定位的父盒子的 X 坐标</td></tr><tr><td align="left">evt.offsetY</td><td align="left">相对于带有定位的父盒子的 Y 坐标</td></tr><tr><td align="left">evt.screenX</td><td align="left">点击位置相对显示器边界的 X 坐标</td></tr><tr><td align="left">evt.screenY</td><td align="left">点击位置相对显示器边界的 Y 坐标</td></tr><tr><td align="left">evt.keycode</td><td align="left">键盘按下键的键值</td></tr><tr><td align="left">event.preventDefault()</td><td align="left">阻止事件的默认动作</td></tr><tr><td align="left">event.stopPropagation()</td><td align="left">停止事件传播</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>DOM JS EVENT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP 连接数据库</title>
    <link href="undefined2019/09/17/PHP%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>2019/09/17/PHP%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<pre><code class="php">    $conn = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;&quot;, &quot;jingdongdong&quot;);    if($conn-&gt;connect_errno){        echo &quot;数据库连接失败&quot; . $conn-&gt;connect_errno;    }    $conn-&gt;close(); //调用对象方法close()以关闭连接 </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>php mysql 数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/09/17/hello-world/"/>
    <url>2019/09/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>