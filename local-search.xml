<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cookie</title>
    <link href="undefined2019/09/20/Cookie/"/>
    <url>2019/09/20/Cookie/</url>
    
    <content type="html"><![CDATA[<h2 id="Cookie-简介"><a href="#Cookie-简介" class="headerlink" title="Cookie 简介 :"></a>Cookie 简介 :</h2><p>http 协议具有无状态的特性 , 而很多站点都有记录信息 ( 如登录状态等 ) 的需求 , 我们通过 Cookie 和 Session 技术来对其进行实现</p><a id="more"></a><p>Cookie 是一种本地存储技术 , 其表现形式是浏览器储存在用户硬盘上的一个很小的文本文件。Cookie 中存储的数据是纯文本 , 没有可执行代码 , 其中包括一些服务器需要的信息 , 每次请求站点 , 会发送相应的cookie , 这些cookie可以用实现辨别用户身份信息 , 记录用户搜索记录等功能</p><h3 id="Cookie-如何记录浏览器的登录状态-会话跟踪"><a href="#Cookie-如何记录浏览器的登录状态-会话跟踪" class="headerlink" title="Cookie 如何记录浏览器的登录状态   ( 会话跟踪 )"></a>Cookie 如何记录浏览器的登录状态   ( 会话跟踪 )</h3><ul><li>浏览器向服务器发送登录请求 , 携带用户名和密码</li><li>服务器进行登录信息的验证 , 如果成功 , 在给浏览器的响应中 , 设定了一个 Cookie ( 如 SID1234765432167 )  </li><li>页面跳转 , 发送的请求中携带了刚才服务器设定的 Cookie ( SID1234765432167 )   </li><li>服务器收到请求后 , 会从 Cookie 中取得 SID , 并验证 ID 值是否有效   </li><li>如果 ID 值有效 , 则返回登录状态的页面</li></ul><h2 id="Cookie-的存取"><a href="#Cookie-的存取" class="headerlink" title="Cookie 的存取"></a>Cookie 的存取</h2><pre><code class="js">document.cookie = &quot;username=CuiJn&quot;; //存Cookiedocument.cookie = &quot;password=123456&quot;document.cookie;    //取Cookie  格式为 &quot;name1=value1; name2=value2; name3=value3&quot;//  这种方法会一次性去除全部 Cookie , 类型为字符串// 取指定 Cookie ↓    需要将 Cookie 字符串进行两次切分实现function getCookie(){    var cookie = document.cookie;    var arr = cookie.split(&quot;; &quot;);    var key_value;    for(let i = 0; i &lt; arr.length; i++){        key_value = arr[i].split(&quot;=&quot;);        if (key_value === &quot;password&quot;) {            return key_value;        }    }    return null;}</code></pre><h2 id="Cookie-选项"><a href="#Cookie-选项" class="headerlink" title="Cookie 选项"></a>Cookie 选项</h2><h3 id="Cookie-路径"><a href="#Cookie-路径" class="headerlink" title="Cookie 路径"></a>Cookie 路径</h3><pre><code class="js">// path: 路径   当 Cookie 设定了路径 , 仅在这一文件夹下的 html 文件 , 可以访问此 Cookie  ( 包括其父级文件夹 ) // 在存 Cookie 时 , 如果没有设定 path  , 则默认设为当前 html 所在文件夹 // 手动设定 path 方式 ↓document.cookie = &quot;name=value;path=url&quot;</code></pre><h3 id="Cookie-有效期"><a href="#Cookie-有效期" class="headerlink" title="Cookie 有效期"></a>Cookie 有效期</h3><pre><code class="js">// 如果系统时间超过了有效时间 , Cookie 会被浏览器删除// 在没有设定有效时间的情况下 , 默认值为 session ( 浏览器关闭后结束 , 删除该 Cookie ) document.cookie = &quot;name=value; expires=Date对象转成的字符串&quot;</code></pre><p><font size="3">利用 Cookie 的有效期 , 可以实现 Cookie 的删除</font></p><pre><code class="js">let d = new Date();d.setDate(d.getDate() - 1);document.cookie = &quot;neme=value; expires=&quot; + d;</code></pre><h2 id="Cookie-的不可取代之处"><a href="#Cookie-的不可取代之处" class="headerlink" title="Cookie 的不可取代之处"></a>Cookie 的不可取代之处</h2><p>Cookie 之所以不可取代 , 是因为它与服务器有联系    </p><ul><li><p>浏览器在发送请求时 , 会自动将当前页面能够访问的 Cookie 发送给服务器<br>  通过请求头 cookie: aaa=bbb; ccc=ddd</p></li><li><p>服务器同样有能力设定浏览器的 Cookie<br>  通过响应头 set-cookie: aaa=bbb;ccc=ddd</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>Cookie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Baidu</title>
    <link href="undefined2019/09/19/FakeBaidu/"/>
    <url>2019/09/19/FakeBaidu/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍一下"><a href="#介绍一下" class="headerlink" title="介绍一下 :"></a>介绍一下 :</h2><p>这是一个关于 Ajax 与 JSONP 的练习，动态获取热搜关键词    </p><a id="more"></a>   <img src="https://s2.ax1x.com/2019/09/19/nLvZHe.png"> <p><font size="4"><center>大概就是这么一个样子 ↑</center></font></p><p>目录结构如下   </p><img src="https://s2.ax1x.com/2019/09/19/nLxWdg.png"><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Fake Baidu&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;div class=&quot;logo&quot;&gt;            &lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png?where=super&quot; width=&quot;270&quot; height=&quot;129&quot;&gt;        &lt;/div&gt;        &lt;form action=&quot;&quot; id=&quot;search&quot;&gt;            &lt;span class=&quot;soutu&quot;&gt;&lt;/span&gt;            &lt;input type=&quot;text&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;百度一下&quot;&gt;            &lt;ul&gt;            &lt;/ul&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><center>这是百度的响应格式 ↓</center>    <img src="https://s2.ax1x.com/2019/09/19/nOSq54.png">    <pre><code class="js">let input = document.querySelector(&#39;input&#39;);    //这里获取的是搜索栏的输入框// 从 Baidu 获取热搜关键词function inp(keyWord) {    let s = document.createElement(&#39;script&#39;);    s.src = `https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web&amp;sugsid=1454,21100,29522,29720,29568,29221,26350&amp;wd=${keyWord}&amp;req=2&amp;csor=3&amp;pwd=wi&amp;cb=search&amp;_=1568883721394`;      // 这段超长的 url 取自百度    document.body.appendChild(s);}// 处理获取到的数据function search(data) {    let ul = document.querySelector(&#39;ul&#39;);    // 对数据的处理，详见上图的响应格式    if (data.g === undefined) return;    let liArr = data.g.map(word =&gt; `&lt;li class=&quot;hot&quot;&gt;${word.q}&lt;/li&gt;`);    ul.innerHTML = liArr.join(&#39;&#39;) + `&lt;li&gt;&lt;a class=&quot;feedBack&quot;&gt;反馈&lt;/a&gt;&lt;/li&gt;`;}input.oninput = function () {    document.querySelector(&#39;ul&#39;).style.display = &quot;block&quot;;    if (input.value == &#39;&#39;) document.querySelector(&#39;ul&#39;).innerHTML = &#39;&#39;;    inp(input.value);   // 调用 inp() 方法 , 利用 JSONP 获取热搜关键词}input.onblur = function () {    // 搜索栏失去焦点时隐藏热搜关键词列表    setTimeout(() =&gt; {        document.querySelector(&#39;ul&#39;).style.display = &quot;none&quot;;    }, 100);}// logodocument.querySelector(&quot;.logo img&quot;).onclick = function () {    location.href = &quot;#&quot;;}// 以下为搜索功能document.querySelector(&quot;input[type=&#39;submit&#39;]&quot;).onclick = function () {    let word = input.value;    location.href = &quot;https://www.baidu.com/s?wd=&quot; + word;}document.querySelector(&quot;ul&quot;).onclick = function (evt) {    console.log(evt.target.className);    if (evt.target.className === &#39;hot&#39;) {        let word = evt.target.innerHTML;        location.href = &quot;https://www.baidu.com/s?wd=&quot; + word;    }}</code></pre><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>css 可以略过，为了好看而已   </p><pre><code class="css">* {    margin: 0;    padding: 0;}ul {    list-style: none;    position: absolute;    z-index: 1;    position: absolute;    box-sizing: border-box;    border: 1px solid #CCC;    box-shadow: 1px 1px 3px #ededed;    -webkit-box-shadow: 1px 1px 3px #ededed;    -moz-box-shadow: 1px 1px 3px #ededed;    -o-box-shadow: 1px 1px 3px #ededed;}ul li {    height: 22px;    line-height: 22px;    width: 534px;    box-sizing: border-box;    font: 14px arial;    line-height: 22px;    padding: 0 8px;    position: relative;    cursor: default;}ul li:not(:last-child):hover {    background-color: #ddd;}ul li:last-child {    height: 27px;    text-align: right;    background: #fafafa;    color: #666;}.feedBack {    margin-right: 10px;    text-decoration: underline;    color: #666;    text-align: right;    line-height: 27px;    font-size: 12px;    cursor: pointer;}input[type=&#39;text&#39;] {    width: 479px;    height: 20px;    display: block;    padding: 9px 48px 9px 7px;    border: 1px solid rgb(204, 204, 204);    border-right: 0;    float: left;    outline: none;    font-size: 16px;}input[type=&#39;text&#39;]:hover {    border-color: #b8b8b8;}input[type=&#39;text&#39;]:focus {    border-color: rgb(51, 136, 255);}/* 38f */input[type=&#39;submit&#39;] {    width: 104px;    height: 40px;    background-color: rgb(51, 136, 255);    font-size: 16px;    font-weight: 400;    line-height: 38px;    text-align: center;    display: inline-block;    border: 0;    box-sizing: border-box;    color: white;    user-select: none;    white-space: pre;    align-items: flex-start;    text-align: center;    -webkit-appearance: push-button;}.box {    height: 293px;    display: block;    width: 641px;    position: absolute;    left: 50%;    margin-left: -328px;}#search {    position: absolute;    bottom: 0;}.soutu {    display: block;    position: absolute;    background: #ccc;    height: 16px;    width: 18px;    background: #fff url(https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/protocol/https/soutu/img/camera_new_5606e8f.png) no-repeat;    bottom: 12px;    left: 506px;    cursor: pointer;}.soutu:hover {    background-position-y: -20px;}.logo {    height: 181px;    width: 100%;    position: absolute;    bottom: 40px;}.logo img {    margin: 33px 0 0 -136px;    position: relative;    left: 50%;    width: 270px;    height: 129px;    cursor: pointer;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSONP跨域请求</title>
    <link href="undefined2019/09/19/JS%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    <url>2019/09/19/JS%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>同源 , 指协议 ( 如HTTP ) , 域名 ( 如localhost ) 和端口 ( 如 8080 ) 三者全部相同 , 其中有任何一个不同 , 都会被认作为不同的域    </p><a id="more"></a><p>同源策略是浏览器的安全机制之一 , 不同源的脚本在默认情况下 , 不能读写对方资源     </p><p>如果非同源 , 那么在请求数据时 , 浏览器会在控制台中报一个异常 , 访问被 CORS 策略阻挡</p><h1 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h1><p>一个从 A 到 B 的请求 , 只要协议 , 域名与端口有任何一个不同 , 就会被认作跨域请求  </p><p>在无明确授权的情况下 , 跨域请求会被浏览器的同源策略所阻拦</p><p>目前比较流行的跨域请求解决方案有三个   </p><ul><li>JSONP</li><li>CORS</li><li>反向代理</li></ul><p>其中 , CORS 与反向代理由后端实现 , JSONP 方案需要前后端配合实现   </p><h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>JSONP 实现跨域请求 , 借助了 <code>&lt;script&gt;&lt;/script&gt;</code> 可以发送跨域请求的特性   </p><p>然而 JSONP 只能发送 GET 请求 , 无法发送 POST 请求   </p><h2 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h2><p>创建 <code>&lt;script&gt;&lt;/script&gt;</code> 节点    </p><pre><code class="js">let s = document.createElement(&#39;script&#39;);</code></pre><h2 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h2><p>将该节点的 src 属性指向请求资源的路径   </p><pre><code class="js">s.src = &quot;url&quot;;</code></pre><h2 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h2><p>将节点挂上 DOM 树</p><pre><code class="js">document.body.appendChild(s);</code></pre><p><code>&lt;script&gt;</code> 节点的位置随意     </p><p>在节点上书后 , 会立刻向指定路径发送请求 , 此时我们可以等待响应</p><h1 id="例"><a href="#例" class="headerlink" title="例"></a>例</h1><pre><code class="js">let s = document.createElement(&#39;script&#39;);s.src = &quot;localhost:80/php/JSONPTest.php?funcName=getData&quot;;function getData(data){    return data;}document.body.appendChild(s);</code></pre><pre><code class="php">$fn = $_GET[&#39;funcName&#39;];$data = &quot;Roland&quot;;echo &quot;$fn($data)&quot;;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>JSONP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP 连接数据库</title>
    <link href="undefined2019/09/17/PHP%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>2019/09/17/PHP%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="PHP-是这世界上最好的语言"><a href="#PHP-是这世界上最好的语言" class="headerlink" title="PHP 是这世界上最好的语言"></a>PHP 是这世界上最好的语言</h3><a id="more"></a><h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><h2 id="数据库信息"><a href="#数据库信息" class="headerlink" title="数据库信息"></a>数据库信息</h2><table><thead><tr><th align="left">类别</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">数据库名</td><td align="left">jingdongdong</td></tr><tr><td align="left">账户</td><td align="left">root</td></tr><tr><td align="left">密码</td><td align="left"></td></tr><tr><td align="left">用户表名</td><td align="left">users</td></tr><tr><td align="left">字段A</td><td align="left">id int ( 6 ) / Primary Key / AUTO_INCREMENT</td></tr><tr><td align="left">字段B</td><td align="left">name varchar ( 20 )</td></tr><tr><td align="left">字段C</td><td align="left">pwd varchar ( 20 )</td></tr><tr><td align="left">字段D</td><td align="left">tel varchar ( 11 )</td></tr></tbody></table><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><pre><code class="html">&lt;form action=&quot;/jingdongdong/api/register.php&quot; method=&quot;POST&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;pwd&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot;&gt;    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Sign Up&lt;/button&gt;&lt;/form&gt;</code></pre><h2 id="PHP代码"><a href="#PHP代码" class="headerlink" title="PHP代码"></a>PHP代码</h2><h3 id="register-php"><a href="#register-php" class="headerlink" title="register.php"></a>register.php</h3><pre><code class="php">// 从请求中取得用户名和密码$user = $_POST[&#39;name&#39;];$pw = $_POST[&#39;pwd&#39;];// 连接数据库$server_name = &#39;localhost:3306&#39;;$dbms_username = &#39;root&#39;;$dbms_password = &#39;&#39;;$db_name = &#39;jingdongdong&#39;;$conn = new mysqli($server_name, $dbms_username, $dbms_password, $db_name);if($conn-&gt;connect_error) {    return;}else{}// 检查用户名是否存在$sql = &quot;    SELECT `id` FROM `users`    WHERE `users`.`name`=&#39;$user&#39;&quot;;$ret = $conn-&gt;query($sql);if($ret-&gt;num_rows &gt; 0) {    // 用户名存在    echo &quot;用户名已经存在&quot;;} else {    // 用户名不存在，则将该用户名和密码插入到表中    $sql = &quot;        INSERT INTO `users`        (`id`, `name`, `pwd`, `tel`)        VALUES        (NULL, &#39;$user&#39;, &#39;$pw&#39;, &#39;13333333333&#39;)    &quot;;    $ret = $conn-&gt;query($sql);    if($ret) {        // 注册成功        // 跳转至登录页        header(&quot;Location: http://localhost:80/jingdongdong/html/login.html&quot;);    } else {        //注册失败        echo &quot;注册失败&quot;;    }}</code></pre><h3 id="check-php"><a href="#check-php" class="headerlink" title="check.php"></a>check.php</h3><pre><code class="php">$user = $_GET[&#39;name&#39;];include &quot;./conn.php&quot;;$sql = &quot;SELECT `id` from `users`        WHERE `users`.`name`=&#39;$user&#39;    &quot;;$ret = $conn-&gt;query($sql);if ($ret-&gt;num_rows &gt; 0) {    //用户名已存在    echo 0;} else {    //用户名可以使用    echo 1;}</code></pre><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><pre><code class="js">var uname = document.querySelector(&#39;input[name=&quot;name&quot;]&#39;);uname.onblur = check;function check() {  // 检测用户名是否存在    let ajax = new XMLHttpRequest();    ajax.open(&quot;get&quot;, `/jingdongdong/api/check.php?name=${uname.value}`, true);    ajax.onreadystatechange = function () {        if (ajax.readyState !== 4) {            return;        }        if (ajax.status &gt;= 200 &amp;&amp; ajax.status &lt; 300) {            if (ajax.responseText == 0) {                uname.style.color = &quot;red&quot;;            } else if (ajax.responseText == 1) {                uname.style.color = &quot;#000&quot;;            }        } else {        }    }    ajax.send();}</code></pre><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><h2 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h2><pre><code class="html">&lt;form action=&quot;/jingdongdong/api/login.php&quot; method=&quot;POST&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;pwd&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot;&gt;    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Sign Up&lt;/button&gt;&lt;/form&gt;</code></pre><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><h3 id="login-php"><a href="#login-php" class="headerlink" title="login.php"></a>login.php</h3><pre><code class="php">$user = $_POST[&#39;name&#39;];$pw = $_POST[&#39;pwd&#39;];// 连接数据库$server_name = &#39;localhost:3306&#39;;$dbms_username = &#39;root&#39;;$dbms_password = &#39;&#39;;$db_name = &#39;jingdongdong&#39;;$conn = new mysqli($server_name, $dbms_username, $dbms_password, $db_name);if($conn-&gt;connect_error) {    return;}else{}// 查询用户名与密码均符合的条目$sql = &quot;SELECT `id` from `users`    WHERE `users`.`name`=&#39;$user&#39; and `users`.`pwd`=&#39;$pw&#39;&quot;;$ret = $conn-&gt;query($sql);if($ret-&gt;num_rows &gt; 0){    // 查询到符合要求的条目，跳转至欢迎页    header(&quot;Location: http://localhost:80/jingdongdong/html/welcome.html&quot;);}else{    echo &quot;Login Failed&quot;;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>php</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM</title>
    <link href="undefined2019/08/06/DOM/"/>
    <url>2019/08/06/DOM/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML-DOM-简介"><a href="#HTML-DOM-简介" class="headerlink" title="HTML DOM 简介 :"></a>HTML DOM 简介 :</h1><h2 id="什么是HTML-DOM"><a href="#什么是HTML-DOM" class="headerlink" title="什么是HTML DOM?"></a>什么是HTML DOM?</h2><p>DOM是W3C的标准 , 它定义了访问 HTML 和 XML 文档的标准 , HTML DOM 则是专门适用于 HTML / XHTML 的文档对象模型   </p><a id="more"></a><p>它定义了访问和操作 HTML 文档的标准方法 , 并将 HTML 文档呈现为带有元素 , 属性与文本的树状结构 </p><p>HTML DOM 独立于平台和编程语言 , 它可被任何编程语言 , 如 Java , JavaScript 和 VBScript 使用</p><h3 id="HTML-DOM-是"><a href="#HTML-DOM-是" class="headerlink" title="HTML DOM 是"></a>HTML DOM 是</h3><ul><li>HTML 的标准对象模型</li><li>HTML 的标准API</li><li>W3C 标准</li></ul><h2 id="DOM-的功能"><a href="#DOM-的功能" class="headerlink" title="DOM 的功能"></a>DOM 的功能</h2><ul><li>查询某个元素</li><li>查询某个元素的祖先、兄弟以及后代元素</li><li>获取、修改元素的属性</li><li>获取、修改元素的内容</li><li>创建、插入和删除元素</li></ul><p>简而言之 , DOM 为页面中的实时数据交互提供了可能性 , JavaScript 通过 DOM 可以访问并操作 HTML 文档中的内容</p><h1 id="DOM-节点"><a href="#DOM-节点" class="headerlink" title="DOM 节点"></a>DOM 节点</h1><h2 id="DOM-节点分类"><a href="#DOM-节点分类" class="headerlink" title="DOM 节点分类"></a>DOM 节点分类</h2><ul><li>整个文档是一个文档节点</li><li>每个 HTML 元素是一个元素节点</li><li>元素内的文本是一个文本节点</li><li>每个元素属性是一个属性节点</li><li>注释为注释节点</li></ul><blockquote><p>HTML DOM 节点树</p></blockquote><img src="https://s2.ax1x.com/2019/08/21/mt7Kr4.gif" width="480"><p>通过 HTML DOM , JavaScript 可以访问树中的任意节点 , 所有节点均可被修改 , 也可以创建或删除节点</p><h2 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">querySelector()</td><td align="left">返回指定选择器或选择器组匹配的第一个元素</td></tr><tr><td align="left">querySelectorAll()</td><td align="left">返回指定选择器或选择器组匹配的全部元素</td></tr><tr><td align="left">getElementById()</td><td align="left">返回带有指定 ID 的元素</td></tr><tr><td align="left">getElementsByTagName()</td><td align="left">返回带有指定标签名的元素的节点列表</td></tr><tr><td align="left">getElementsByClassName()</td><td align="left">返回带有指定类名的元素的节点列表</td></tr><tr><td align="left">appendChild()</td><td align="left">把新的子节点添加到指定节点</td></tr><tr><td align="left">removeChild()</td><td align="left">删除子节点</td></tr><tr><td align="left">replaceChild()</td><td align="left">替换子节点</td></tr><tr><td align="left">insertBefore()</td><td align="left">在指定的子节点前面插入新的子节点</td></tr><tr><td align="left">createAttribute()</td><td align="left">创建属性节点</td></tr><tr><td align="left">createElement()</td><td align="left">创建元素节点</td></tr><tr><td align="left">createTextNode()</td><td align="left">创建文本节点</td></tr><tr><td align="left">getAttribute()</td><td align="left">返回指定的属性值</td></tr><tr><td align="left">setAttribute()</td><td align="left">把指定属性设置或修改为指定的值</td></tr><tr><td align="left">removeAttribute()</td><td align="left">删除指定的属性</td></tr></tbody></table><h3 id="document-querySelector-selectors"><a href="#document-querySelector-selectors" class="headerlink" title="document.querySelector(selectors)"></a>document.querySelector(selectors)</h3><p>说明 : 按照指定 CSS 选择器返回第一个匹配的元素</p><pre><code class="js">var el = document.querySelector(&quot;div.user-panel.main input[name=&#39;login&#39;]&quot;);</code></pre><p>若使用多个选择器 , 中间使用逗号隔开</p><h3 id="document-querySelectorAll-selectors"><a href="#document-querySelectorAll-selectors" class="headerlink" title="document.querySelectorAll(selectors)"></a>document.querySelectorAll(selectors)</h3><p>说明 : 按照指定CSS选择器返回全部的元素</p><p>返回值为对象集合 , 使用方法类似 querySelector()</p><h3 id="document-getElementById-id"><a href="#document-getElementById-id" class="headerlink" title="document.getElementById(id)"></a>document.getElementById(id)</h3><p>说明 : 按照指定 id 取得元素对象 , 如果 id 重复 , 则返回第一个对象</p><p>document.getElementById(id) 的返回值是一个对象 , 有 value 和 length 等属性</p><h3 id="document-getElementsByTagName-tagName"><a href="#document-getElementsByTagName-tagName" class="headerlink" title="document.getElementsByTagName(tagName)"></a>document.getElementsByTagName(tagName)</h3><p>说明 : 按照标签名取得元素节点列表</p><p>此方法的返回值是一个伪数组 , 只支持length属性 , 它是一个动态的元素节点集合 , 会根据 DOM 树的变化自动更新</p><p>如果想对getElementsByTagName()返回值调用数组方法 , 可将其转化为数组</p><p>方法如下</p><pre><code class="js">var divObjs=document.getElementsByTagName(&quot;div&quot;);// 方法一Array.prototype.slice.call(divObjs); // 方法二  此方法IE不支持Array.from(divObjs);// 方法三 : 声明一个空数组，遍历伪数组中的元素添加到空数组中。 </code></pre><h3 id="document-getElementsByClassName-className"><a href="#document-getElementsByClassName-className" class="headerlink" title="document.getElementsByClassName(className)"></a>document.getElementsByClassName(className)</h3><p>说明 : 按照指定 class 取得元素对象列表<br>其返回值形式同getElementsByTagName()</p><p>注意 , IE8以下及以下浏览器 , 不支持此方法 , 请勿使用 IE8 及以下浏览器</p><h3 id="node-appendChild-node"><a href="#node-appendChild-node" class="headerlink" title="node.appendChild(node)"></a>node.appendChild(node)</h3><p>说明 : 在节点的子节点列表末尾添加节点 , 或将一个节点的子节点移动到另一个节点下</p><p>添加子节点</p><pre><code class="html">&lt;ul id=&quot;list1&quot;&gt;    &lt;li&gt;A&lt;/li&gt;    &lt;li&gt;B&lt;/li&gt;&lt;/ul&gt;&lt;ul id=&quot;list2&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="js">var newNode=document.createElement(&quot;li&quot;);var textNode = document.createTextNode(&#39;C&#39;);newNode.appendChild(textNode);//创建节点 &lt;li&gt;C&lt;/li&gt;document.getElementById(&#39;list1&#39;).appendChild(newNode);//添加新节点到id为list的元素内</code></pre><p>移动子节点</p><pre><code class="html">&lt;ul id=&quot;list1&quot;&gt;    &lt;li&gt;A&lt;/li&gt;    &lt;li&gt;B&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;    &lt;li id=&quot;li&quot;&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="js">var li=document.getElementById(&quot;li&quot;);document.getElementById(&#39;list1&#39;).appendChild(li);//移动 id 为 &quot;li&quot; 的节点到 id 为 list 的元素内</code></pre><h3 id="node-removeChild-node"><a href="#node-removeChild-node" class="headerlink" title="node.removeChild(node)"></a>node.removeChild(node)</h3><p>说明 : 从DOM中删除子节点<br>返回值为被删除的子节点 , 该节点已从DOM树中删除 , 但仍然存在于内存中</p><h3 id="node-removeChild-child"><a href="#node-removeChild-child" class="headerlink" title="node.removeChild(child);"></a>node.removeChild(child);</h3><p>在这种情况下 , 被删除的节点很快会被内存管理回收 , 如果需要保留此节点 , 可使用如下方式</p><pre><code class="js">var nodeDel = node.removeChild(child);</code></pre><h3 id="node-replaceChild-newNode-oldNode"><a href="#node-replaceChild-newNode-oldNode" class="headerlink" title="node.replaceChild(newNode, oldNode)"></a>node.replaceChild(newNode, oldNode)</h3><p>说明 : 将某个节点替换为另一个 , 原节点会被从 DOM 树中删除<br>返回值为原节点 (oldchild)</p><h3 id="node-insertBefore-newNode-existingnode"><a href="#node-insertBefore-newNode-existingnode" class="headerlink" title="node.insertBefore(newNode, existingnode)"></a>node.insertBefore(newNode, existingnode)</h3><p>说明 : 将一个节点插入到另一个节点前<br>返回值为新插入的节点 (newNode)</p><p>与 appendChild() 的作用有一定相似<br>insertBefore() 在节点前插入节点 , 相对于兄弟节点<br>appendChild() 在末尾插入节点 , 相对于父级节点</p><h3 id="document-createAttribute-attribute"><a href="#document-createAttribute-attribute" class="headerlink" title="document.createAttribute(attribute)"></a>document.createAttribute(attribute)</h3><p>说明 : 创建一个指定名称的属性节点<br>参数为属性名 , 返回值为 Attr 对象属性 , 此方法仅能创建一条属性 , 并不会设置具体属性值</p><p>设置属性值方法如下 </p><pre><code class="html">&lt;p&gt;test&lt;/p&gt;</code></pre><pre><code class="js">var attr = document.createAttribute(&quot;style&quot;);attr.nodeValue = &quot;color: #f06&quot;;var p=document.getElementsByTagName(&#39;p&#39;)[0];  p.setAttributeNode(attr);   </code></pre><p>效果如下   </p><pre><code class="html">&lt;p style=&quot;color: #f06&quot;&gt;test&lt;/p&gt;</code></pre><p>注  </p><p>setAttribute() 方法与 createAttribute() 方法作用类似 , 但可以直接添加属性及属性值 , 使用更简便</p><pre><code class="js">element.setAttribute(attributename,attributevalue)  </code></pre><h3 id="document-createElement-tagName"><a href="#document-createElement-tagName" class="headerlink" title="document.createElement(tagName)"></a>document.createElement(tagName)</h3><p>说明 : 创建一个元素节点 , 即一个HTML元素<br>返回值为新创建的元素 , 与 appendChild() 或 insertBefore() 方法搭配使用 , 以在任意位置插入一个新建节点</p><pre><code class="js">var btn = document.createElement(&quot;input&quot;);btn.type = &quot;button&quot;;btn.value = &quot;新建按钮&quot;;</code></pre><h3 id="document-createTextNode-data"><a href="#document-createTextNode-data" class="headerlink" title="document.createTextNode(data)"></a>document.createTextNode(data)</h3><p>说明 : 创建一个文本节点<br>返回值为此文本节点对象 , 文本节点中的内容均为文本 , 无论其格式如何<br>例如</p><pre><code class="js">var text = document.createTextNode(&quot;&lt;div&gt;Hello&lt;/div&gt;&quot;);</code></pre><p>在浏览器中会显示 <code>&lt;div&gt;Hello&lt;/div&gt;</code>本身 , 而不会显示一个内容为 “ Hello” 的 div</p><h3 id="node-getAttribute-data"><a href="#node-getAttribute-data" class="headerlink" title="node.getAttribute(data)"></a>node.getAttribute(data)</h3><p>说明 : 取得某一节点的某一属性值<br>返回此属性的属性值 , 是一个字符串</p><pre><code class="js">var node = document.getElementById(&#39;node&#39;);console.log(node.getAttribute(&#39;name&#39;));node.setAttribute(data)</code></pre><p>说明 : 添加指定的属性 , 并为其赋指定的值<br>返回指定属性的属性值 , 如果这个指定的属性已存在 , 则仅设置 / 更改值</p><pre><code class="js">var node = document.getElementById(&#39;node&#39;);node.setAttribute(&#39;name&#39;, &#39;thisIsTheNode&#39;);node.removeAttribute(data)</code></pre><p>说明 : 删除指定的属性<br>返回被删除的属性 , 此方法不支持 IE 浏览器</p><pre><code class="js">var node = document.getElementById(&#39;node&#39;);node.removeAttribute(&#39;name&#39;);</code></pre><h1 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h1><h2 id="nodeName-nodeValue-nodeType"><a href="#nodeName-nodeValue-nodeType" class="headerlink" title="nodeName, nodeValue, nodeType"></a>nodeName, nodeValue, nodeType</h2><p>这三个属性的值取决于节点的类型</p><h3 id="nodeName-节点名称"><a href="#nodeName-节点名称" class="headerlink" title="nodeName 节点名称"></a>nodeName 节点名称</h3><ul><li>元素节点的 nodeName 是标签名称 (大写)</li><li>属性节点的 nodeName 是属性名称</li><li>文本节点的 nodeName 永远是 #text</li><li>文档节点的 nodeName 永远是 #document</li></ul><pre><code class="js">console.log(document.nodeName); //#documentconsole.log(element.nodeName);  //DIVconsole.log(attr.nodeName);     //idconsole.log(text.nodeName);     //#text</code></pre><h3 id="nodeValue-节点值"><a href="#nodeValue-节点值" class="headerlink" title="nodeValue 节点值"></a>nodeValue 节点值</h3><ul><li>对于文本节点，nodeValue 属性包含文本。</li><li>对于属性节点，nodeValue 属性包含属性值。</li><li>文档节点和元素节点，nodeValue 属性的值始</li></ul><h3 id="nodeType-节点类型"><a href="#nodeType-节点类型" class="headerlink" title="nodeType 节点类型"></a>nodeType 节点类型</h3><table><thead><tr><th align="left">常量名</th><th align="left">常量值</th><th align="left">节点类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Node.ELEMENT_NODE</td><td align="left">1</td><td align="left">Element</td><td align="left">代表元素节点</td></tr><tr><td align="left">Node.ATTRIBUTE_NODE</td><td align="left">2</td><td align="left">Attr</td><td align="left">代表属性节点</td></tr><tr><td align="left">Node.TEXT_NODE</td><td align="left">3</td><td align="left">Text</td><td align="left">代表文本节点</td></tr><tr><td align="left">Node.COMMENT_NODE</td><td align="left">8</td><td align="left">Comment</td><td align="left">代表注释节点</td></tr><tr><td align="left">Node.DOCUMENT_NODE</td><td align="left">9</td><td align="left">Document</td><td align="left">代表整个文档</td></tr></tbody></table><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><h3 id="textContent-innerText-innerHTML"><a href="#textContent-innerText-innerHTML" class="headerlink" title="textContent / innerText / innerHTML"></a>textContent / innerText / innerHTML</h3><pre><code class="html">&lt;div id=&quot;element&quot;&gt;    &lt;p&gt;Test text&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="js">var element = document.getElementById(&#39;element&#39;)console.log(element.innerHTML)  //    &lt;p&gt;Test text&lt;/p&gt;console.log(element.innerText)  //Test textconsole.log(element.textContent)//    Test text   </code></pre><p>innerHTML : 获取节点内的元素与文本 , 以 string 类型存储<br>innerText : 获取节点内的文本 ( 不包括空白字符 )<br>textContent : 获取节点内的文本 ( 包括空白字符 )   </p><h3 id="parentNode-parentElement-父节点-父元素"><a href="#parentNode-parentElement-父节点-父元素" class="headerlink" title="parentNode / parentElement 父节点 / 父元素"></a>parentNode / parentElement 父节点 / 父元素</h3><p>取得某一节点的父节点 / 取得某一节点的父元素<br>一般情况下 , 这两种属性的值是相等的 , 特例为根节点 document , document 属于节点 , 但不是元素节点 , 此时 parentNode 的值为#document , 但 parentElement 的值为 null</p><h3 id="previousSibling-previousElementChild-前一个兄弟节点-前一个兄弟元素"><a href="#previousSibling-previousElementChild-前一个兄弟节点-前一个兄弟元素" class="headerlink" title="previousSibling / previousElementChild 前一个兄弟节点 / 前一个兄弟元素"></a>previousSibling / previousElementChild 前一个兄弟节点 / 前一个兄弟元素</h3><p>previousSibling 不仅能够返回子元素(ElementNode) , 还可能取得文本节点(TextNode) , 谨慎使用<br>IE8以下浏览器中 previousSibling 会取得前一个兄弟元素 , 且不支持previousElementChild    </p><h3 id="nextSibling-nextElementChild-下一个兄弟节点-下一个兄弟元素"><a href="#nextSibling-nextElementChild-下一个兄弟节点-下一个兄弟元素" class="headerlink" title="nextSibling / nextElementChild 下一个兄弟节点 / 下一个兄弟元素"></a>nextSibling / nextElementChild 下一个兄弟节点 / 下一个兄弟元素</h3><p>使用方法 , 特性及兼容性与 previousSibling / previousElementChild 相似    </p><h3 id="childNodes-children-子节点集合-子元素集合"><a href="#childNodes-children-子节点集合-子元素集合" class="headerlink" title="childNodes / children 子节点集合 / 子元素集合"></a>childNodes / children 子节点集合 / 子元素集合</h3><p>同 firstChild / firstElementChild , childNodes 能够取得文本节点 , 但 children 只会取得元素节点<br>在 firefox 与 chrome 等主流浏览器中 , 会将 空格 / 制表符 / 换行 等空白字符解析为空的文本节点 , 在使用 childNodes 时 , 需要注意这些空白字符     </p><h3 id="firstChild-firstElementChild-首个子节点-首个子元素"><a href="#firstChild-firstElementChild-首个子节点-首个子元素" class="headerlink" title="firstChild / firstElementChild 首个子节点 / 首个子元素"></a>firstChild / firstElementChild 首个子节点 / 首个子元素</h3><p>取得某一节点的第一个子节点 / 取得某一节点的第一个子元素<br>firstChild 不仅能够取得子元素(ElementNode) , 还能取得文本节点(TextNode) , 谨慎使用     </p><p>可使用 firstElementChild 获取节点的第一个元素节点</p><p>发现有如下写法 , 原发布者认为可以使用这种方法避免firstChild取得文本节点 , 而得到元素节点</p><pre><code class="js">firstChild(element);//ReferenceError: firstChild is not defined</code></pre><p>Firfox 与 Chrome 测试时报错 , 方法不可行</p><p>兼容性 : IE8 以下浏览器中 firstChild 会取得第一个元素节点 , firstElementChild 不兼容</p><h3 id="lastChild-lastElementChild-最后一个子节点-最后一个子元素"><a href="#lastChild-lastElementChild-最后一个子节点-最后一个子元素" class="headerlink" title="lastChild / lastElementChild 最后一个子节点 / 最后一个子元素"></a>lastChild / lastElementChild 最后一个子节点 / 最后一个子元素</h3><p>使用方法与特性与 firstChild / firstElementChild 相似<br>兼容性 : IE8 以下浏览器 lastChild 会取得最后一个元素节点 , 不支持lastElementChild   </p><h1 id="HTML-DOM-事件-Event"><a href="#HTML-DOM-事件-Event" class="headerlink" title="HTML DOM 事件 (Event)"></a>HTML DOM 事件 (Event)</h1><h2 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h2><ul><li>事件源 触发事件的对象</li><li>事件类型 如何触发事件</li><li>事件处理程序 通过函数的方式处理<pre><code class="js">element.onclick = function(){Alert(&#39;Clicked&#39;);}</code></pre></li></ul><h2 id="事件流-EventFlow"><a href="#事件流-EventFlow" class="headerlink" title="事件流 (EventFlow)"></a>事件流 (EventFlow)</h2><h3 id="事件发生的过程"><a href="#事件发生的过程" class="headerlink" title="事件发生的过程"></a>事件发生的过程</h3><p>在事件触发时，页面元素接受触发事件的顺序，被称为事件流，在事件流的定义上，微软 ( IE ) 与网景 (Netscape) 提出了完全相反的观点</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>当事件发生时，触发事件元素的外侧节点先获得信息，目标节点应该最后接收到事件，是一个由外向里的过程，Netscape 支持此观点</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>当事件发生时，整个事件流从从里向外的，由目标节点接收，逐层向上级节点传递，IE 支持此观点    </p><p>这样的分歧造成了浏览器兼容性的差异<br>为缓解分歧，W3C定义了DOM事件流，即    </p><p>先事件捕获，到达具体目标，再事件排序    </p><p>在这个过程中，每一个相关节点都会收到两次事件</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="DOM-0"><a href="#DOM-0" class="headerlink" title="DOM 0"></a>DOM 0</h3><p>在DOM标准定义之前的阶段，称作 DOM 0 阶段<br>DOM 0 的事件处理程序有以下特点</p><ul><li>只能处理冒泡阶段的事件</li><li>同一个元素的同一个事件，重复绑定会覆盖</li><li>this 指向 on 之前的元素</li><li>兼容性好 ( 兼容 IE )</li></ul><h4 id="绑定-DOM-0-事件"><a href="#绑定-DOM-0-事件" class="headerlink" title="绑定 DOM 0 事件"></a>绑定 DOM 0 事件</h4><pre><code class="html">&lt;body&gt;    &lt;div&gt;        &lt;button&gt;BTN&lt;/button&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><pre><code class="js">var btn = document.querySelector(&#39;button&#39;);var div = document.querySelector(&#39;div&#39;);var bdy = document.querySelector(&#39;body&#39;);btn.onclick = function(){    console.log(this.tagName)}div.onclick = function(){    console.log(this.tagName)}bdy.onclick = function(){    console.log(this.tagName)}//点击Button , 控制台输出如下//BUTTON//DIV//BODY    </code></pre><p>可见 , DOM 0 的事件处理程序并没有处理捕获阶段的事件</p><h4 id="清除-DOM-0-事件"><a href="#清除-DOM-0-事件" class="headerlink" title="清除 DOM 0 事件"></a>清除 DOM 0 事件</h4><pre><code class="js">btn.onclick = null;</code></pre><h3 id="DOM-2"><a href="#DOM-2" class="headerlink" title="DOM 2"></a>DOM 2</h3><p>相对 DOM 0 , DOM 2 可以多次绑定同一事件 , 即同一事件再次绑定不会覆盖 , 而按照绑定顺序先后执行   </p><h4 id="绑定-DOM-2-事件"><a href="#绑定-DOM-2-事件" class="headerlink" title="绑定 DOM 2 事件"></a>绑定 DOM 2 事件</h4><pre><code class="js">element.addEventListener(&#39;click&#39;, func, false);</code></pre><p>第一个参数为事件句柄<br>第二个参数指定事件处理函数<br>第三个参数指定事件在捕获阶段还是冒泡阶段执行 , true 为捕获阶段 , false 为冒泡阶段    </p><h4 id="清除-DOM-2-事件"><a href="#清除-DOM-2-事件" class="headerlink" title="清除 DOM 2 事件"></a>清除 DOM 2 事件</h4><pre><code class="js">element.removeEventListener(&quot;click&quot;, func);</code></pre><p>要清除 DOM 2 事件 , 在绑定事件时使用的事件处理函数必须为外部函数 , 如果该函数为匿名函数 , 该事件是无法清除的  </p><h2 id="事件对象-Event"><a href="#事件对象-Event" class="headerlink" title="事件对象 (Event)"></a>事件对象 (Event)</h2><p>事件对象中存放着与发生的事件相关联的信息 , 如光标位置 , 键盘按下的键值     </p><h3 id="取得事件对象的方法"><a href="#取得事件对象的方法" class="headerlink" title="取得事件对象的方法"></a>取得事件对象的方法</h3><ul><li>事件处理函数的参数</li><li>window.event </li></ul><pre><code class="js">window.onclick = function(evt) {    var e = evt || window.event;    //如果 evt 有值，则取用 evt 的值，否则使用window.event的值    //处理 IE8 以下浏览器兼容性问题}</code></pre><h3 id="事件对象相关属性与方法"><a href="#事件对象相关属性与方法" class="headerlink" title="事件对象相关属性与方法"></a>事件对象相关属性与方法</h3><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">event.type</td><td align="left">触发的事件类型</td></tr><tr><td align="left">event.target</td><td align="left">事件的目标元素</td></tr><tr><td align="left">evt.clintX</td><td align="left">点击位置相对浏览器边界的 X 坐标</td></tr><tr><td align="left">evt.clintY</td><td align="left">点击位置相对浏览器边界的 Y 坐标</td></tr><tr><td align="left">evt.pageX</td><td align="left">点击位置相对页面边界的 X 坐标</td></tr><tr><td align="left">evt.pageY</td><td align="left">点击位置相对页面边界的 Y 坐标</td></tr><tr><td align="left">evt.offsetX</td><td align="left">相对于带有定位的父盒子的 X 坐标</td></tr><tr><td align="left">evt.offsetY</td><td align="left">相对于带有定位的父盒子的 Y 坐标</td></tr><tr><td align="left">evt.screenX</td><td align="left">点击位置相对显示器边界的 X 坐标</td></tr><tr><td align="left">evt.screenY</td><td align="left">点击位置相对显示器边界的 Y 坐标</td></tr><tr><td align="left">evt.keycode</td><td align="left">键盘按下键的键值</td></tr><tr><td align="left">event.preventDefault()</td><td align="left">阻止事件的默认动作</td></tr><tr><td align="left">event.stopPropagation()</td><td align="left">停止事件传播</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Array</title>
    <link href="undefined2019/07/21/Array/"/>
    <url>2019/07/21/Array/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数组是一组数据的集合 , 在一个数组中 , 数组元素可以是任何类型 , 在内存中是一段连续的内存空间   </p><a id="more"></a><p>每个元素在数组中占据一个位置 , 称为索引 , 索引从 0 开始 , 最大值为数组长度减 1</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ul><li><p>直接创建</p><pre><code class="js">  var arrA = [];//空数组  var arrB = [1,2,3]//三个值的数组  var arrC = [1,&#39;string&#39;, Object, true,]//有不同类型数据的数组 , 最后一个逗号为结尾的逗号  //结尾的逗号可以去掉 , 在主流浏览器中可兼容（IE8 以下浏览器未测试）</code></pre></li><li><p>构造函数创建</p><pre><code class="js">  var arrD = new Array();//空数组  var arrE = new Array(5);//[empty × 5]  var arrF = new Array(1,2,3,4,5);//[1,2,3,4,5]</code></pre></li></ul><h2 id="遍历-迭代"><a href="#遍历-迭代" class="headerlink" title="遍历 / 迭代"></a>遍历 / 迭代</h2><pre><code class="js">var arr = new Array(1,2,3,4,5)for(var i in arr){    console.log(arr[i]);}</code></pre><p>以上的for in循环等价于</p><pre><code class="js">for(var i = 0 ; i &lt; arr.length ; i++){    console.log(arr[i]);}</code></pre><h1 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h1><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">concat()</td><td align="left">连接两个或更多的数组 , 并返回结果</td></tr><tr><td align="left">join()</td><td align="left">把所有数组元素放入一个字符串 , 元素通过指定的分隔符进行分隔</td></tr><tr><td align="left">reverse()</td><td align="left">反转数组中元素的顺序</td></tr><tr><td align="left">slice()</td><td align="left">从某个已有的数组返回选定的元素</td></tr><tr><td align="left">splice()</td><td align="left">删除元素 , 并向数组添加新元素</td></tr><tr><td align="left">indexOf()</td><td align="left">查找元素在数组中的位置</td></tr><tr><td align="left">lastIndexOf()</td><td align="left">从后向前开始查找元素在数组中的位置</td></tr><tr><td align="left">pop()</td><td align="left">删除并返回数组的最后一个元素</td></tr><tr><td align="left">push()</td><td align="left">向数组的末尾添加一个或更多元素</td></tr><tr><td align="left">shift()</td><td align="left">删除并返回数组的第一个元素</td></tr><tr><td align="left">unshift()</td><td align="left">向数组的开头添加一个或更多元素</td></tr><tr><td align="left">valueOf()</td><td align="left">返回数组对象的原始值</td></tr><tr><td align="left">sort()</td><td align="left">对数组的元素进行排序</td></tr><tr><td align="left">toString()</td><td align="left">把数组转换为字符串 , 并返回结果</td></tr><tr><td align="left">toLocaleString()</td><td align="left">把数组转换为本地数组 , 并返回结果</td></tr><tr><td align="left">map()</td><td align="left">将数组中的每个元素调用一个提供的函数 , 原数组不变</td></tr><tr><td align="left">forEach()</td><td align="left">将数组中的每个元素执行传进提供的函数 , 原数组改变</td></tr><tr><td align="left">filter()</td><td align="left">对所有元素进行判断 , 将满足条件的元素作为一个新的数组返回</td></tr><tr><td align="left">every()</td><td align="left">将所有元素进行判断 , 所有元素都满足判断条件 , 则返回true</td></tr><tr><td align="left">some()</td><td align="left">将所有元素进行判断 , 存在元素都满足判断条件 , 则返回true</td></tr></tbody></table><h2 id="arrayObject-concat-array1-array2-……-arrayN"><a href="#arrayObject-concat-array1-array2-……-arrayN" class="headerlink" title="arrayObject.concat(array1, array2, …… , arrayN)"></a>arrayObject.concat(array1, array2, …… , arrayN)</h2><p>将数组进行连接 , 返回连接后的新数组 , 不改变原数组</p><pre><code class="js">var arrA = new Array(1, 2, 3);console.log(arrA.concat(4, 5));//[1, 2, 3, 4, 5]var arrB = new Array(1, 2);var arrC = new Array(3, 4);var arrD = new Array(5, 6);var arr = arrB.concat(arrC, arrD)console.log(arr);//[1, 2, 3, 4, 5, 6]</code></pre><h2 id="arrayObject-join-separator"><a href="#arrayObject-join-separator" class="headerlink" title="arrayObject.join(separator)"></a>arrayObject.join(separator)</h2><p>将数组中的所有元素放入一个字符串 , 元素之间用指定的分隔符分隔<br>参数 separator (分隔符) 可选 , 如参数缺省 , 默认使用逗号作为分隔府<br>不改变原数组</p><pre><code class="js">var arrE = [a, b, c];console.log(arrE.join());//a-b-c</code></pre><p>注 : String.split() 与 join() 的功能相反 , 将字符串按照指定的分隔符切割为数组 , 搭配使用 , 可实现反转字符串功能</p><pre><code class="js">var info = &quot;Hello!&quot;info.split(&#39;&#39;);//分隔符为空字符串console.log(info);//[&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]info = info.reverse().join(&#39;&#39;);console.log(info);//olleH</code></pre><h2 id="arrayObject-reverse"><a href="#arrayObject-reverse" class="headerlink" title="arrayObject.reverse()"></a>arrayObject.reverse()</h2><p>将数组中全部元素顺序反转 , 此方法改变原数组</p><h2 id="arrayObject-slice-startIndex-endIndex"><a href="#arrayObject-slice-startIndex-endIndex" class="headerlink" title="arrayObject.slice(startIndex, endIndex)"></a>arrayObject.slice(startIndex, endIndex)</h2><p>将数组中指定索引之间的元素截取 , 存储至一个新数组中 , 返回新数组<br>不改变原数组  </p><p>startIndex : 开始截取位置<br>endIndex : 结束截取位置   </p><p>截取元素索引从startIndex所在元素开始 , 包括此元素 , 截取至endIndex所在元素为止 , 不包括第二个参数所指向的元素   </p><pre><code class="js">var arr = new Array(1,2,3,4,5,6,7,8,9);console.log(arr.slice(2,6));//3,4,5,6</code></pre><p>特点</p><ul><li>如果不传入参数 , slice() 会截取整个数组 , 相当于将数组复制了一次</li><li>如果只传入一个参数 , 会从此参数所指的元素开始 , 截取至最后一个元素 ( 包括最后一个元素 )</li><li>如果参数为负值 , 代表倒数第几个 , 此时参数不再等同于元素索引 , 如 -1 指倒数第一个元素</li><li>如果第一个参数所在位置在第二个参数之后 , 返回空数组   </li></ul><h2 id="arrayObject-splice-start-deleteCount-item1-item2-item3…"><a href="#arrayObject-splice-start-deleteCount-item1-item2-item3…" class="headerlink" title="arrayObject.splice(start, deleteCount, item1, item2, item3…)"></a>arrayObject.splice(start, deleteCount, item1, item2, item3…)</h2><p>在指定位置对数组进行编辑 , 改变原数组<br>返回被删除的元素组成的新数组 , 如果未删除元素 , 返回空数组</p><p>start : 开始操作的位置<br>deleteCount : 删除元素的个数 , 如果不删除 , 传入 0<br>item1, item2… : 在操作位置插入的元素   </p><h2 id="arrayObject-indexOf-item-start"><a href="#arrayObject-indexOf-item-start" class="headerlink" title="arrayObject.indexOf(item, start)"></a>arrayObject.indexOf(item, start)</h2><p>查找指定元素在数组中的索引 , 找到了返回索引 , 未找到返回 -1</p><p>item : 要查找的元素的元素值<br>start : 开始查找的位置 ( 索引值 )<br>arrayObject.lastIndexOf(item, start)    </p><p>功能与 indexOf() 相似 , 但从数组后向前查找    </p><p>注 两种方法查找方式均为按元素值查找 , 在有重复元素的数组中 , 返回值可能并不相同</p><h2 id="arrayObject-push-item1-item2-item3……"><a href="#arrayObject-push-item1-item2-item3……" class="headerlink" title="arrayObject.push(item1, item2, item3……)"></a>arrayObject.push(item1, item2, item3……)</h2><p>将元素放在数组的最后面 , 返回值为新数组长度 , 改变原数组</p><h2 id="arrayObject-pop"><a href="#arrayObject-pop" class="headerlink" title="arrayObject.pop()"></a>arrayObject.pop()</h2><p>将数组的最后一个元素删除 , 返回被删除元素的值 , 原数组改变</p><h2 id="arrayObject-unshift-item1-item2-item3……"><a href="#arrayObject-unshift-item1-item2-item3……" class="headerlink" title="arrayObject.unshift(item1, item2, item3……)"></a>arrayObject.unshift(item1, item2, item3……)</h2><p>将元素插入到数组的开头 , 返回值为新数组长度 , 改变原数组</p><h2 id="arrayObject-shift"><a href="#arrayObject-shift" class="headerlink" title="arrayObject.shift()"></a>arrayObject.shift()</h2><p>将数组开头的元素删除 , 返回被删除元素的值 , 原数组改变</p><h2 id="arrayObject-valueOf"><a href="#arrayObject-valueOf" class="headerlink" title="arrayObject.valueOf()"></a>arrayObject.valueOf()</h2><p>返回数组元素本身 (Object)</p><h2 id="arrayObject-sort-function"><a href="#arrayObject-sort-function" class="headerlink" title="arrayObject.sort(function)"></a>arrayObject.sort(function)</h2><p>对数组元素进行排序，改变原数组，返回对数组的引用</p><p>不带参数调用 sort() 时，排序后的结果并不按照数值大小排列，而是以字母表顺序 ( ACSII码顺序 ) 进行排序 ( 如有必要将临时转化为字符串 )<br>当带参数调用 sort() 时，会按照参数 ( function类型 ) 中设定的排序方式进行排序</p><p>以下是对 sort() 的基本分析</p><pre><code class="js">function mySort(func){    if(func == undefined){//无参数情况下，比较ASCII码        for(var i=0;i&lt;theArray.length;i++){            for(var j=0;j&lt;theArray.length-i;j++){                var temp;                if(theArray[j]&gt;theArray[j+1]){                    temp = theArray[j];                    theArray[j] = theArray[j+1];                    theArray[j+1] = temp;                }            }        }    }    else if(typeof func == &#39;function&#39;){        for(var i=0;i&lt;theArray.length-1;i++){            for(var j=0;j&lt;theArray.length-i-1;j++){                var temp;                var decide = func(theArray[j], theArray[j+1]);                if(decide&gt;0){                    //按照传入参数的返回值执行排序                    //返回值大于 0，说明array[j]&gt;array[j+1]                    //此时交换元素值                    temp = theArray[j];                    theArray[j] = theArray[j+1];                    theArray[j+1] = temp;                }            }        }    }    return theArray;}</code></pre><p>一个简单的排序函数</p><pre><code class="js">arr.sort(function(a,b){    return a-b;});arrayObject.toString()返回表示函数源代码的字符串var arr = [1,6,4,2,8,&quot;asd&quot;,true,,,&quot;aszxs&quot;]console.log(arr.toString())//1,6,4,2,8,asd,true,,,aszxs</code></pre>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型转换</title>
    <link href="undefined2019/07/11/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>2019/07/11/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h1><p>不同类型的变量比较要先转类型, 通常发生在运算符加减乘除, 等于, 还有大于, 小于等   </p><a id="more"></a><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul><li><p>字符串加数字, 数字就会转成字符串</p></li><li><p>数字减字符串, 字符串转成数字, 反之亦然<br>  如果字符串不是纯数字, 就会返回 NaN<br>  乘, 除, 大于, 小于的转换也是一样</p></li><li><p>字符串和数字比较时，字符串转数字</p></li><li><p>数字为布尔比较时，布尔转数字</p></li><li><p>字符串和布尔比较时，两者转数字</p></li><li><p>undefined等于null</p></li></ul><p>例如  </p><pre><code class="js">console.log(10+&#39;20&#39;) //2010 Stringconsole.log(10-&#39;20&#39;)//-10 numberconsole.log(10-&#39;one&#39;) //NaNconsole.log(10-&#39;101a&#39;) //NaNconsole.log(10*&#39;20&#39;) //200 numberconsole.log(&#39;10&#39;*&#39;20&#39;) //200 numberconsole.log(20/&#39;10&#39;) //2 numberconsole.log(&#39;20&#39;/&#39;10&#39;) //2 numberconsole.log(&#39;20&#39;/&#39;one&#39;) //NaNconsole.log(&#39;0&#39;==0) //trueconsole.log(0==false) //trueconsole.log(&#39;0&#39;==false) //trueconsole.log(null==false) //falseconsole.log(undefined==false) //falseconsole.log(undefined==null) //true</code></pre><h1 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h1><pre><code class="js">parseInt() &amp; parseFloat()parseInt(&quot;1234blue&quot;);   //returns 1234parseInt(&quot;0xA&quot;);        //returns 10parseInt(&quot;  22.5&quot;);     //returns 22parseInt(&quot;22   5&quot;);     //returns 22parseInt(&quot;blue&quot;);       //returns NaNparseFloat(&quot;1234blue&quot;); //returns 1234.0parseFloat(&quot;0xA&quot;);      //returns NaNparseFloat(&quot;  22.5  &quot;); //returns 22.5parseFloat(&quot;22.34.5&quot;);  //returns 22.34parseFloat(&quot;0908&quot;);     //returns 908parseFloat(&quot;blue&quot;);     //returns NaN</code></pre><p>parse 意为 “解析”<br>parseInt() 将值转换成整数, parseFloat() 将值转换成浮点数</p><p>这两个函数只能对 String 类型使用,其他类型会返回 NaN  </p><pre><code class="js">parseInt(&quot;AF&quot;, 16);     //returns 175parseInt(&quot;10&quot;, 2);      //returns 2parseInt(&quot;10&quot;, 8);      //returns 8parseInt(&quot;10&quot;, 10);     //returns 10   </code></pre><p>parsrInt() 可以进行进制转换, 将16进制, 8进制, 2进制或其他进制的字符串转换为整数, 进制由方法的第二个参数指定</p><pre><code class="js">parseInt(&quot;010&quot;);        //returns 8parseInt(&quot;010&quot;, 8);     //returns 8parseInt(&quot;010&quot;, 10);    //returns 10</code></pre><p>如果十进制数包含前导0, 那么最好指明第二个参数为10, 这样才不会意外地得到八进制的值</p><h2 id="window-Number"><a href="#window-Number" class="headerlink" title="window.Number()"></a>window.Number()</h2><p>可以将任意类型的参数mix转换为数值类型  </p><p>如果是布尔值, true和false分别被转换为1和0</p><p>如果是数字值, 返回本身<br>如果是null, 返回0<br>如果是undefined, 返回NaN<br>如果是字符串, 遵循以下规则  </p><ul><li>如果字符串中只包含数字, 则将其转换为十进制 ( 忽略前导 0 )</li><li>如果字符串中包含有效的浮点格式, 将其转换为浮点数值 ( 忽略前导 0 )</li><li>如果是空字符串, 返回 0</li><li>如果字符串中无以上格式, 则将其转换为NaN</li><li>如果是对象, 则调用对象的valueOf()方法, 然后依据前面的规则转换返回的值。如果转换的结果是NaN, 则调用对象的toString()方法, 再次依照前面的规则转换返回的字符串值   </li></ul><pre><code class="js">Number(null)         //0Number(undefined)    //NaNNumber(true)         //1Number(false)        //0Number(&quot;  123 456  &quot;)//NaNNumber(&quot;  123456   &quot;)//123456Number(&quot;  123.456  &quot;)//123.456Number(&quot;  123.45.6 &quot;)//NaN</code></pre><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>除undefined和null之外的所有类型的值都具有toString()方法, 其作用是返回对象的字符串表示</p><table><thead><tr><th align="left">对象</th><th align="left">操作</th></tr></thead><tbody><tr><td align="left">Array</td><td align="left">将 Array 的元素转换为字符串 , 结果字符串由逗号分隔, 且连接起来</td></tr><tr><td align="left">Boolean</td><td align="left">如果 Boolean 值是 true, 则返回 “true” , 否则返回 “false”</td></tr><tr><td align="left">Date</td><td align="left">返回日期的文字表示法</td></tr><tr><td align="left">Error</td><td align="left">返回一个包含相关错误信息的字符串</td></tr><tr><td align="left">Function</td><td align="left">返回如下格式的字符串 : function func() { [native code] }</td></tr><tr><td align="left">Number</td><td align="left">返回数字的文字表示</td></tr><tr><td align="left">String</td><td align="left">返回 String 对象的值</td></tr><tr><td align="left">默认</td><td align="left">返回 “ [ object obj ] ”</td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h2><p>将任何类型的值转换为字符串</p><ul><li>如果有toString()方法, 则调用该方法 ( 不传递radix参数 ) 并返回结果</li><li>如果是null, 返回”null”</li><li>如果是undefined, 返回”undefined”  </li></ul><h2 id="window-Boolean"><a href="#window-Boolean" class="headerlink" title="window.Boolean()"></a>window.Boolean()</h2><p>将任何类型的值转换为布尔值  </p><p>以下值会被转换为false</p><pre><code class="js">window.Boolean(false);      //falsewindow.Boolean(&quot;&quot;);         //falsewindow.Boolean(0);          //falsewindow.Boolean(NaN);        //falsewindow.Boolean(null);       //falsewindow.Boolean(undefined);  //false</code></pre><p>其余所有值都会返回 true</p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端布局</title>
    <link href="undefined2019/06/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/"/>
    <url>2019/06/24/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一-弹性布局-百分比布局-流式布局-——拉勾网、天猫首页"><a href="#一-弹性布局-百分比布局-流式布局-——拉勾网、天猫首页" class="headerlink" title="一 弹性布局 ( 百分比布局, 流式布局 ) ——拉勾网、天猫首页"></a>一 弹性布局 ( 百分比布局, 流式布局 ) ——拉勾网、天猫首页</h1><p>优点 : 充分发挥大手机的优势——显示内容更多   </p><p>缺点 : 屏幕过大会造成元素间距过大, 比例失调</p><p>特点 : </p><a id="more"></a><p>顶部与底部的bar不管分辨率怎么变, 它的高度和位置都不变<br>例如 , 中间每条招聘信息不管分辨率怎么变 , 招聘公司的图标等信息都位于条目的左边 , 薪资都位于右边   </p><p>如何识别手机尺寸 通过设置meta语句 : </p><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;</code></pre><p>在网页的中增加这句话 , 可以让网页的宽度自动适应手机屏幕的宽度</p><p>也可以写成 : </p><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot; /&gt;  </code></pre><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">width</td><td align="left">可视区域的宽度</td></tr><tr><td align="left">height</td><td align="left">可视区域的高度</td></tr><tr><td align="left">device-width</td><td align="left">设备屏幕的宽度</td></tr><tr><td align="left">initial-scale</td><td align="left">页面首次被显示时的缩放级别 ( 0-10.0 ) , 取值为1时页面按实际尺寸显示, 无任何缩放</td></tr><tr><td align="left">minimum-scale</td><td align="left">设定最小缩小比例 ( 0-10.0 ) , 取值为1时将禁止用户缩小至实际尺寸之下</td></tr><tr><td align="left">maximum-scale</td><td align="left">设定最大放大比例 ( 0-10.0 ) , 取值为1时将禁止用户放大至实际尺寸之上</td></tr><tr><td align="left">user-scalable</td><td align="left">设定用户是否可以缩放 ( yes/no )</td></tr></tbody></table><h2 id="viewport的概念"><a href="#viewport的概念" class="headerlink" title="viewport的概念"></a>viewport的概念</h2><p>移动设备上的 viewport 就是设备的屏幕上能用来显示我们的网页的那一块区域, 但 viewport 又不局限于浏览器可视区域的大小 , 它可能比浏览器的可视区域要大 , 也可能比浏览器的可视区域要小   </p><p>在默认情况下 , 一般来讲 , 移动设备上的 viewport 都是要大于浏览器可视区域的 , 这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小 , 所以为了能在移动设备上正常显示那些传统的、为桌面浏览器设计的网站 , 移动设备上的浏览器都会把自己默认的 viewport 设为 980px 或 1024px ( 也可能是其它值 , 这个是由设备自己决定的 ) , 但带来的后果就是浏览器会出现横向滚动条 , 因为浏览器可视区域的宽度比这个默认的 viewport 的宽度要小</p><h2 id="关于像素"><a href="#关于像素" class="headerlink" title="关于像素"></a>关于像素</h2><p>在css中, 我们一般使用px作为单位, 在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素, 这可能会造成我们的一个错觉, 那就是css中的像素就是设备的物理像. 但实际情况却并非如此, css中的像素只是一个抽象的单位, 在不同的设备或不同的环境中, css中的1px所代表的设备物理像素是不同的. 在为桌面浏览器设计的网页中, 我们无需对这个斤斤计较, 但在移动设备上, 必须弄明白这点   </p><p>在早先的移动设备中, 屏幕像素密度都比较低, 如iphone3, 它的分辨率为320x480, 在iphone3上, 一个css像素确实是等于一个屏幕物理像素的. 后来随着技术的发展, 移动设备的屏幕像素密度越来越高, 从iphone4开始, 苹果公司便推出了所谓的Retina屏, 分辨率提高了一倍, 变成640x960, 但屏幕尺寸却没变化, 这就意味着同样大小的屏幕上, 像素却多了一倍, 这时, 一个css像素是等于两个物理像素的  </p><p>注 :<br>devicePixelRatio 设备像素比 (DPR)</p><p>Retina屏 —–视网膜屏幕</p><h1 id="二-等比缩放布局-rem布局-——网易、淘宝首页"><a href="#二-等比缩放布局-rem布局-——网易、淘宝首页" class="headerlink" title="二 等比缩放布局 ( rem布局 ) ——网易、淘宝首页"></a>二 等比缩放布局 ( rem布局 ) ——网易、淘宝首页</h1><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>视口(viewport)设置</p><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1, minimum-scale=1&quot;&gt;</code></pre><p>在html上根据不同分辨率设置不同 font-size</p><p>页面里除了 font-size 之外的其它 css 尺寸都使用了 rem 作为单位</p><p>正文的 font-size 需要额外的媒介查询, 并且不使用 rem</p><p>例如   </p><pre><code class="css">@media screen and (max-width: 320px) {body{    font-size: 12px;  }}@media screen and (min-width:320px) and (max-width: 375px) {body{    font-size: 14px;  }}@media screen and (min-width: 375px) and (max-width: 414px) {body{    font-size: 16px;  }}@media screen and (min-width: 414px) {body{    font-size: 18px;  }}</code></pre><h1 id="VW"><a href="#VW" class="headerlink" title="VW"></a>VW</h1><p>vw是可视区宽度单位 1vw等于可视区宽度的百分之一</p><p>100vw = 可视窗口宽度</p><p>100vh = 可视窗口高度</p><p>1vw = 1% 视口宽 ( viewport ) </p><p>在 iPhone6 中根字号等于100px的时候, 视口宽等于375</p><p>html— font-size : 100 px</p><p>在 iPhone6 中根字号 100px , 1vw = 3.75 px , 然后将 px 单位转换为 vw , 让其随着视口变化而变化</p><p>1vw == 3.75 px<br>？ vw == 100 px</p><p>26.67 vw 等于 100px 所以就将 HTML 的字号设置为 26.67vw , 这样HTML的字号就会随着视口变化而变化了</p><p>在rem布局里 , 文字不推荐转换为rem , 可以使用媒体查询</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>移动端</tag>
      
      <tag>REM</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>