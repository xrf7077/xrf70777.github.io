<!DOCTYPE html>
<html lang="en">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/r85.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content>
  <meta name="author" content="Roland Edgeworth">
  <meta name="keywords" content>
  <title>DOM ~ Rol.E</title>
  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css">
  <link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">
  
    <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">
  
  <link rel="stylesheet" href="/css/main.css">

  
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Rol.E</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2"
         style="background: url('/img/bg.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              <p>Tuesday, August 6th 2019, 12:00 am</p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto">
          <div class="markdown-body">
            <h1 id="HTML-DOM-简介"><a href="#HTML-DOM-简介" class="headerlink" title="HTML DOM 简介"></a>HTML DOM 简介</h1><h2 id="什么是HTML-DOM"><a href="#什么是HTML-DOM" class="headerlink" title="什么是HTML DOM?"></a>什么是HTML DOM?</h2><p>DOM是W3C的标准 , 它定义了访问 HTML 和 XML 文档的标准 , HTML DOM 则是专门适用于 HTML / XHTML 的文档对象模型   </p>
<a id="more"></a>
<p>它定义了访问和操作 HTML 文档的标准方法 , 并将 HTML 文档呈现为带有元素 , 属性与文本的树状结构 </p>
<p>HTML DOM 独立于平台和编程语言 , 它可被任何编程语言 , 如 Java , JavaScript 和 VBScript 使用</p>
<h3 id="HTML-DOM-是"><a href="#HTML-DOM-是" class="headerlink" title="HTML DOM 是"></a>HTML DOM 是</h3><ul>
<li>HTML 的标准对象模型</li>
<li>HTML 的标准API</li>
<li>W3C 标准</li>
</ul>
<h2 id="DOM-的功能"><a href="#DOM-的功能" class="headerlink" title="DOM 的功能"></a>DOM 的功能</h2><ul>
<li>查询某个元素</li>
<li>查询某个元素的祖先、兄弟以及后代元素</li>
<li>获取、修改元素的属性</li>
<li>获取、修改元素的内容</li>
<li>创建、插入和删除元素</li>
</ul>
<p>简而言之 , DOM 为页面中的实时数据交互提供了可能性 , JavaScript 通过 DOM 可以访问并操作 HTML 文档中的内容</p>
<h1 id="DOM-节点"><a href="#DOM-节点" class="headerlink" title="DOM 节点"></a>DOM 节点</h1><h2 id="DOM-节点分类"><a href="#DOM-节点分类" class="headerlink" title="DOM 节点分类"></a>DOM 节点分类</h2><ul>
<li>整个文档是一个文档节点</li>
<li>每个 HTML 元素是一个元素节点</li>
<li>元素内的文本是一个文本节点</li>
<li>每个元素属性是一个属性节点</li>
<li>注释为注释节点</li>
</ul>
<blockquote>
<p>HTML DOM 节点树</p>
</blockquote>
<img src="https://s2.ax1x.com/2019/08/21/mt7Kr4.gif" width="480">

<p>通过 HTML DOM , JavaScript 可以访问树中的任意节点 , 所有节点均可被修改 , 也可以创建或删除节点</p>
<h2 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h2><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">querySelector()</td>
<td align="left">返回指定选择器或选择器组匹配的第一个元素</td>
</tr>
<tr>
<td align="left">querySelectorAll()</td>
<td align="left">返回指定选择器或选择器组匹配的全部元素</td>
</tr>
<tr>
<td align="left">getElementById()</td>
<td align="left">返回带有指定 ID 的元素</td>
</tr>
<tr>
<td align="left">getElementsByTagName()</td>
<td align="left">返回带有指定标签名的元素的节点列表</td>
</tr>
<tr>
<td align="left">getElementsByClassName()</td>
<td align="left">返回带有指定类名的元素的节点列表</td>
</tr>
<tr>
<td align="left">appendChild()</td>
<td align="left">把新的子节点添加到指定节点</td>
</tr>
<tr>
<td align="left">removeChild()</td>
<td align="left">删除子节点</td>
</tr>
<tr>
<td align="left">replaceChild()</td>
<td align="left">替换子节点</td>
</tr>
<tr>
<td align="left">insertBefore()</td>
<td align="left">在指定的子节点前面插入新的子节点</td>
</tr>
<tr>
<td align="left">createAttribute()</td>
<td align="left">创建属性节点</td>
</tr>
<tr>
<td align="left">createElement()</td>
<td align="left">创建元素节点</td>
</tr>
<tr>
<td align="left">createTextNode()</td>
<td align="left">创建文本节点</td>
</tr>
<tr>
<td align="left">getAttribute()</td>
<td align="left">返回指定的属性值</td>
</tr>
<tr>
<td align="left">setAttribute()</td>
<td align="left">把指定属性设置或修改为指定的值</td>
</tr>
<tr>
<td align="left">removeAttribute()</td>
<td align="left">删除指定的属性</td>
</tr>
</tbody></table>
<h3 id="document-querySelector-selectors"><a href="#document-querySelector-selectors" class="headerlink" title="document.querySelector(selectors)"></a>document.querySelector(selectors)</h3><p>说明 : 按照指定 CSS 选择器返回第一个匹配的元素</p>
<pre><code class="js">var el = document.querySelector(&quot;div.user-panel.main input[name=&#39;login&#39;]&quot;);</code></pre>
<p>若使用多个选择器 , 中间使用逗号隔开</p>
<h3 id="document-querySelectorAll-selectors"><a href="#document-querySelectorAll-selectors" class="headerlink" title="document.querySelectorAll(selectors)"></a>document.querySelectorAll(selectors)</h3><p>说明 : 按照指定CSS选择器返回全部的元素</p>
<p>返回值为对象集合 , 使用方法类似 querySelector()</p>
<h3 id="document-getElementById-id"><a href="#document-getElementById-id" class="headerlink" title="document.getElementById(id)"></a>document.getElementById(id)</h3><p>说明 : 按照指定 id 取得元素对象 , 如果 id 重复 , 则返回第一个对象</p>
<p>document.getElementById(id) 的返回值是一个对象 , 有 value 和 length 等属性</p>
<h3 id="document-getElementsByTagName-tagName"><a href="#document-getElementsByTagName-tagName" class="headerlink" title="document.getElementsByTagName(tagName)"></a>document.getElementsByTagName(tagName)</h3><p>说明 : 按照标签名取得元素节点列表</p>
<p>此方法的返回值是一个伪数组 , 只支持length属性 , 它是一个动态的元素节点集合 , 会根据 DOM 树的变化自动更新</p>
<p>如果想对getElementsByTagName()返回值调用数组方法 , 可将其转化为数组</p>
<p>方法如下</p>
<pre><code class="js">var divObjs=document.getElementsByTagName(&quot;div&quot;);
// 方法一
Array.prototype.slice.call(divObjs); 
// 方法二  此方法IE不支持
Array.from(divObjs);
// 方法三 : 声明一个空数组，遍历伪数组中的元素添加到空数组中。 </code></pre>
<h3 id="document-getElementsByClassName-className"><a href="#document-getElementsByClassName-className" class="headerlink" title="document.getElementsByClassName(className)"></a>document.getElementsByClassName(className)</h3><p>说明 : 按照指定 class 取得元素对象列表<br>其返回值形式同getElementsByTagName()</p>
<p>注意 , IE8以下及以下浏览器 , 不支持此方法 , 请勿使用 IE8 及以下浏览器</p>
<h3 id="node-appendChild-node"><a href="#node-appendChild-node" class="headerlink" title="node.appendChild(node)"></a>node.appendChild(node)</h3><p>说明 : 在节点的子节点列表末尾添加节点 , 或将一个节点的子节点移动到另一个节点下</p>
<p>添加子节点</p>
<pre><code class="html">&lt;ul id=&quot;list1&quot;&gt;
    &lt;li&gt;A&lt;/li&gt;
    &lt;li&gt;B&lt;/li&gt;
&lt;/ul&gt;
&lt;ul id=&quot;list2&quot;&gt;
    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre><code class="js">var newNode=document.createElement(&quot;li&quot;);
var textNode = document.createTextNode(&#39;C&#39;);
newNode.appendChild(textNode);//创建节点 &lt;li&gt;C&lt;/li&gt;
document.getElementById(&#39;list1&#39;).appendChild(newNode);
//添加新节点到id为list的元素内</code></pre>
<p>移动子节点</p>
<pre><code class="html">&lt;ul id=&quot;list1&quot;&gt;
    &lt;li&gt;A&lt;/li&gt;
    &lt;li&gt;B&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
    &lt;li id=&quot;li&quot;&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre><code class="js">var li=document.getElementById(&quot;li&quot;);
document.getElementById(&#39;list1&#39;).appendChild(li);
//移动 id 为 &quot;li&quot; 的节点到 id 为 list 的元素内</code></pre>
<h3 id="node-removeChild-node"><a href="#node-removeChild-node" class="headerlink" title="node.removeChild(node)"></a>node.removeChild(node)</h3><p>说明 : 从DOM中删除子节点<br>返回值为被删除的子节点 , 该节点已从DOM树中删除 , 但仍然存在于内存中</p>
<h3 id="node-removeChild-child"><a href="#node-removeChild-child" class="headerlink" title="node.removeChild(child);"></a>node.removeChild(child);</h3><p>在这种情况下 , 被删除的节点很快会被内存管理回收 , 如果需要保留此节点 , 可使用如下方式</p>
<pre><code class="js">var nodeDel = node.removeChild(child);</code></pre>
<h3 id="node-replaceChild-newNode-oldNode"><a href="#node-replaceChild-newNode-oldNode" class="headerlink" title="node.replaceChild(newNode, oldNode)"></a>node.replaceChild(newNode, oldNode)</h3><p>说明 : 将某个节点替换为另一个 , 原节点会被从 DOM 树中删除<br>返回值为原节点 (oldchild)</p>
<h3 id="node-insertBefore-newNode-existingnode"><a href="#node-insertBefore-newNode-existingnode" class="headerlink" title="node.insertBefore(newNode, existingnode)"></a>node.insertBefore(newNode, existingnode)</h3><p>说明 : 将一个节点插入到另一个节点前<br>返回值为新插入的节点 (newNode)</p>
<p>与 appendChild() 的作用有一定相似<br>insertBefore() 在节点前插入节点 , 相对于兄弟节点<br>appendChild() 在末尾插入节点 , 相对于父级节点</p>
<h3 id="document-createAttribute-attribute"><a href="#document-createAttribute-attribute" class="headerlink" title="document.createAttribute(attribute)"></a>document.createAttribute(attribute)</h3><p>说明 : 创建一个指定名称的属性节点<br>参数为属性名 , 返回值为 Attr 对象属性 , 此方法仅能创建一条属性 , 并不会设置具体属性值</p>
<p>设置属性值方法如下 </p>
<pre><code class="html">&lt;p&gt;test&lt;/p&gt;</code></pre>
<pre><code class="js">var attr = document.createAttribute(&quot;style&quot;);
attr.nodeValue = &quot;color: #f06&quot;;
var p=document.getElementsByTagName(&#39;p&#39;)[0];  
p.setAttributeNode(attr);   </code></pre>
<p>效果如下   </p>
<pre><code class="html">&lt;p style=&quot;color: #f06&quot;&gt;test&lt;/p&gt;</code></pre>
<p>注  </p>
<p>setAttribute() 方法与 createAttribute() 方法作用类似 , 但可以直接添加属性及属性值 , 使用更简便</p>
<pre><code class="js">element.setAttribute(attributename,attributevalue)  </code></pre>
<h3 id="document-createElement-tagName"><a href="#document-createElement-tagName" class="headerlink" title="document.createElement(tagName)"></a>document.createElement(tagName)</h3><p>说明 : 创建一个元素节点 , 即一个HTML元素<br>返回值为新创建的元素 , 与 appendChild() 或 insertBefore() 方法搭配使用 , 以在任意位置插入一个新建节点</p>
<pre><code class="js">var btn = document.createElement(&quot;input&quot;);
btn.type = &quot;button&quot;;
btn.value = &quot;新建按钮&quot;;</code></pre>
<h3 id="document-createTextNode-data"><a href="#document-createTextNode-data" class="headerlink" title="document.createTextNode(data)"></a>document.createTextNode(data)</h3><p>说明 : 创建一个文本节点<br>返回值为此文本节点对象 , 文本节点中的内容均为文本 , 无论其格式如何<br>例如</p>
<pre><code class="js">var text = document.createTextNode(&quot;&lt;div&gt;Hello&lt;/div&gt;&quot;);</code></pre>
<p>在浏览器中会显示 <code>&lt;div&gt;Hello&lt;/div&gt;</code>本身 , 而不会显示一个内容为 “ Hello” 的 div</p>
<h3 id="node-getAttribute-data"><a href="#node-getAttribute-data" class="headerlink" title="node.getAttribute(data)"></a>node.getAttribute(data)</h3><p>说明 : 取得某一节点的某一属性值<br>返回此属性的属性值 , 是一个字符串</p>
<pre><code class="js">var node = document.getElementById(&#39;node&#39;);
console.log(node.getAttribute(&#39;name&#39;));
node.setAttribute(data)</code></pre>
<p>说明 : 添加指定的属性 , 并为其赋指定的值<br>返回指定属性的属性值 , 如果这个指定的属性已存在 , 则仅设置 / 更改值</p>
<pre><code class="js">var node = document.getElementById(&#39;node&#39;);
node.setAttribute(&#39;name&#39;, &#39;thisIsTheNode&#39;);
node.removeAttribute(data)</code></pre>
<p>说明 : 删除指定的属性<br>返回被删除的属性 , 此方法不支持 IE 浏览器</p>
<pre><code class="js">var node = document.getElementById(&#39;node&#39;);
node.removeAttribute(&#39;name&#39;);</code></pre>
<h1 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h1><h2 id="nodeName-nodeValue-nodeType"><a href="#nodeName-nodeValue-nodeType" class="headerlink" title="nodeName, nodeValue, nodeType"></a>nodeName, nodeValue, nodeType</h2><p>这三个属性的值取决于节点的类型</p>
<h3 id="nodeName-节点名称"><a href="#nodeName-节点名称" class="headerlink" title="nodeName 节点名称"></a>nodeName 节点名称</h3><ul>
<li>元素节点的 nodeName 是标签名称 (大写)</li>
<li>属性节点的 nodeName 是属性名称</li>
<li>文本节点的 nodeName 永远是 #text</li>
<li>文档节点的 nodeName 永远是 #document</li>
</ul>
<pre><code class="js">console.log(document.nodeName); //#document
console.log(element.nodeName);  //DIV
console.log(attr.nodeName);     //id
console.log(text.nodeName);     //#text</code></pre>
<h3 id="nodeValue-节点值"><a href="#nodeValue-节点值" class="headerlink" title="nodeValue 节点值"></a>nodeValue 节点值</h3><ul>
<li>对于文本节点，nodeValue 属性包含文本。</li>
<li>对于属性节点，nodeValue 属性包含属性值。</li>
<li>文档节点和元素节点，nodeValue 属性的值始</li>
</ul>
<h3 id="nodeType-节点类型"><a href="#nodeType-节点类型" class="headerlink" title="nodeType 节点类型"></a>nodeType 节点类型</h3><table>
<thead>
<tr>
<th align="left">常量名</th>
<th align="left">常量值</th>
<th align="left">节点类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Node.ELEMENT_NODE</td>
<td align="left">1</td>
<td align="left">Element</td>
<td align="left">代表元素节点</td>
</tr>
<tr>
<td align="left">Node.ATTRIBUTE_NODE</td>
<td align="left">2</td>
<td align="left">Attr</td>
<td align="left">代表属性节点</td>
</tr>
<tr>
<td align="left">Node.TEXT_NODE</td>
<td align="left">3</td>
<td align="left">Text</td>
<td align="left">代表文本节点</td>
</tr>
<tr>
<td align="left">Node.COMMENT_NODE</td>
<td align="left">8</td>
<td align="left">Comment</td>
<td align="left">代表注释节点</td>
</tr>
<tr>
<td align="left">Node.DOCUMENT_NODE</td>
<td align="left">9</td>
<td align="left">Document</td>
<td align="left">代表整个文档</td>
</tr>
</tbody></table>
<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><h3 id="textContent-innerText-innerHTML"><a href="#textContent-innerText-innerHTML" class="headerlink" title="textContent / innerText / innerHTML"></a>textContent / innerText / innerHTML</h3><pre><code class="html">&lt;div id=&quot;element&quot;&gt;
    &lt;p&gt;Test text&lt;/p&gt;
&lt;/div&gt;</code></pre>
<pre><code class="js">var element = document.getElementById(&#39;element&#39;)

console.log(element.innerHTML)  //    &lt;p&gt;Test text&lt;/p&gt;
console.log(element.innerText)  //Test text
console.log(element.textContent)//    Test text   </code></pre>
<p>innerHTML : 获取节点内的元素与文本 , 以 string 类型存储<br>innerText : 获取节点内的文本 ( 不包括空白字符 )<br>textContent : 获取节点内的文本 ( 包括空白字符 )   </p>
<h3 id="parentNode-parentElement-父节点-父元素"><a href="#parentNode-parentElement-父节点-父元素" class="headerlink" title="parentNode / parentElement 父节点 / 父元素"></a>parentNode / parentElement 父节点 / 父元素</h3><p>取得某一节点的父节点 / 取得某一节点的父元素<br>一般情况下 , 这两种属性的值是相等的 , 特例为根节点 document , document 属于节点 , 但不是元素节点 , 此时 parentNode 的值为#document , 但 parentElement 的值为 null</p>
<h3 id="previousSibling-previousElementChild-前一个兄弟节点-前一个兄弟元素"><a href="#previousSibling-previousElementChild-前一个兄弟节点-前一个兄弟元素" class="headerlink" title="previousSibling / previousElementChild 前一个兄弟节点 / 前一个兄弟元素"></a>previousSibling / previousElementChild 前一个兄弟节点 / 前一个兄弟元素</h3><p>previousSibling 不仅能够返回子元素(ElementNode) , 还可能取得文本节点(TextNode) , 谨慎使用<br>IE8以下浏览器中 previousSibling 会取得前一个兄弟元素 , 且不支持previousElementChild    </p>
<h3 id="nextSibling-nextElementChild-下一个兄弟节点-下一个兄弟元素"><a href="#nextSibling-nextElementChild-下一个兄弟节点-下一个兄弟元素" class="headerlink" title="nextSibling / nextElementChild 下一个兄弟节点 / 下一个兄弟元素"></a>nextSibling / nextElementChild 下一个兄弟节点 / 下一个兄弟元素</h3><p>使用方法 , 特性及兼容性与 previousSibling / previousElementChild 相似    </p>
<h3 id="childNodes-children-子节点集合-子元素集合"><a href="#childNodes-children-子节点集合-子元素集合" class="headerlink" title="childNodes / children 子节点集合 / 子元素集合"></a>childNodes / children 子节点集合 / 子元素集合</h3><p>同 firstChild / firstElementChild , childNodes 能够取得文本节点 , 但 children 只会取得元素节点<br>在 firefox 与 chrome 等主流浏览器中 , 会将 空格 / 制表符 / 换行 等空白字符解析为空的文本节点 , 在使用 childNodes 时 , 需要注意这些空白字符     </p>
<h3 id="firstChild-firstElementChild-首个子节点-首个子元素"><a href="#firstChild-firstElementChild-首个子节点-首个子元素" class="headerlink" title="firstChild / firstElementChild 首个子节点 / 首个子元素"></a>firstChild / firstElementChild 首个子节点 / 首个子元素</h3><p>取得某一节点的第一个子节点 / 取得某一节点的第一个子元素<br>firstChild 不仅能够取得子元素(ElementNode) , 还能取得文本节点(TextNode) , 谨慎使用     </p>
<p>可使用 firstElementChild 获取节点的第一个元素节点</p>
<p>发现有如下写法 , 原发布者认为可以使用这种方法避免firstChild取得文本节点 , 而得到元素节点</p>
<pre><code class="js">firstChild(element);//ReferenceError: firstChild is not defined</code></pre>
<p>Firfox 与 Chrome 测试时报错 , 方法不可行</p>
<p>兼容性 : IE8 以下浏览器中 firstChild 会取得第一个元素节点 , firstElementChild 不兼容</p>
<h3 id="lastChild-lastElementChild-最后一个子节点-最后一个子元素"><a href="#lastChild-lastElementChild-最后一个子节点-最后一个子元素" class="headerlink" title="lastChild / lastElementChild 最后一个子节点 / 最后一个子元素"></a>lastChild / lastElementChild 最后一个子节点 / 最后一个子元素</h3><p>使用方法与特性与 firstChild / firstElementChild 相似<br>兼容性 : IE8 以下浏览器 lastChild 会取得最后一个元素节点 , 不支持lastElementChild   </p>
<h1 id="HTML-DOM-事件-Event"><a href="#HTML-DOM-事件-Event" class="headerlink" title="HTML DOM 事件 (Event)"></a>HTML DOM 事件 (Event)</h1><h2 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h2><ul>
<li>事件源 触发事件的对象</li>
<li>事件类型 如何触发事件</li>
<li>事件处理程序 通过函数的方式处理<pre><code class="js">element.onclick = function(){
Alert(&#39;Clicked&#39;);
}</code></pre>
</li>
</ul>
<h2 id="事件流-EventFlow"><a href="#事件流-EventFlow" class="headerlink" title="事件流 (EventFlow)"></a>事件流 (EventFlow)</h2><h3 id="事件发生的过程"><a href="#事件发生的过程" class="headerlink" title="事件发生的过程"></a>事件发生的过程</h3><p>在事件触发时，页面元素接受触发事件的顺序，被称为事件流，在事件流的定义上，微软 ( IE ) 与网景 (Netscape) 提出了完全相反的观点</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>当事件发生时，触发事件元素的外侧节点先获得信息，目标节点应该最后接收到事件，是一个由外向里的过程，Netscape 支持此观点</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>当事件发生时，整个事件流从从里向外的，由目标节点接收，逐层向上级节点传递，IE 支持此观点    </p>
<p>这样的分歧造成了浏览器兼容性的差异<br>为缓解分歧，W3C定义了DOM事件流，即    </p>
<p>先事件捕获，到达具体目标，再事件排序    </p>
<p>在这个过程中，每一个相关节点都会收到两次事件</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="DOM-0"><a href="#DOM-0" class="headerlink" title="DOM 0"></a>DOM 0</h3><p>在DOM标准定义之前的阶段，称作 DOM 0 阶段<br>DOM 0 的事件处理程序有以下特点</p>
<ul>
<li>只能处理冒泡阶段的事件</li>
<li>同一个元素的同一个事件，重复绑定会覆盖</li>
<li>this 指向 on 之前的元素</li>
<li>兼容性好 ( 兼容 IE )</li>
</ul>
<h4 id="绑定-DOM-0-事件"><a href="#绑定-DOM-0-事件" class="headerlink" title="绑定 DOM 0 事件"></a>绑定 DOM 0 事件</h4><pre><code class="html">&lt;body&gt;
    &lt;div&gt;
        &lt;button&gt;BTN&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;</code></pre>
<pre><code class="js">var btn = document.querySelector(&#39;button&#39;);
var div = document.querySelector(&#39;div&#39;);
var bdy = document.querySelector(&#39;body&#39;);
btn.onclick = function(){
    console.log(this.tagName)
}
div.onclick = function(){
    console.log(this.tagName)
}
bdy.onclick = function(){
    console.log(this.tagName)
}
//点击Button , 控制台输出如下
//BUTTON
//DIV
//BODY    </code></pre>
<p>可见 , DOM 0 的事件处理程序并没有处理捕获阶段的事件</p>
<h4 id="清除-DOM-0-事件"><a href="#清除-DOM-0-事件" class="headerlink" title="清除 DOM 0 事件"></a>清除 DOM 0 事件</h4><pre><code class="js">btn.onclick = null;</code></pre>
<h3 id="DOM-2"><a href="#DOM-2" class="headerlink" title="DOM 2"></a>DOM 2</h3><p>相对 DOM 0 , DOM 2 可以多次绑定同一事件 , 即同一事件再次绑定不会覆盖 , 而按照绑定顺序先后执行   </p>
<h4 id="绑定-DOM-2-事件"><a href="#绑定-DOM-2-事件" class="headerlink" title="绑定 DOM 2 事件"></a>绑定 DOM 2 事件</h4><pre><code class="js">element.addEventListener(&#39;click&#39;, func, false);</code></pre>
<p>第一个参数为事件句柄<br>第二个参数指定事件处理函数<br>第三个参数指定事件在捕获阶段还是冒泡阶段执行 , true 为捕获阶段 , false 为冒泡阶段    </p>
<h4 id="清除-DOM-2-事件"><a href="#清除-DOM-2-事件" class="headerlink" title="清除 DOM 2 事件"></a>清除 DOM 2 事件</h4><pre><code class="js">element.removeEventListener(&quot;click&quot;, func);</code></pre>
<p>要清除 DOM 2 事件 , 在绑定事件时使用的事件处理函数必须为外部函数 , 如果该函数为匿名函数 , 该事件是无法清除的  </p>
<h2 id="事件对象-Event"><a href="#事件对象-Event" class="headerlink" title="事件对象 (Event)"></a>事件对象 (Event)</h2><p>事件对象中存放着与发生的事件相关联的信息 , 如光标位置 , 键盘按下的键值     </p>
<h3 id="取得事件对象的方法"><a href="#取得事件对象的方法" class="headerlink" title="取得事件对象的方法"></a>取得事件对象的方法</h3><ul>
<li>事件处理函数的参数</li>
<li>window.event </li>
</ul>
<pre><code class="js">window.onclick = function(evt) {
    var e = evt || window.event;
    //如果 evt 有值，则取用 evt 的值，否则使用window.event的值
    //处理 IE8 以下浏览器兼容性问题
}</code></pre>
<h3 id="事件对象相关属性与方法"><a href="#事件对象相关属性与方法" class="headerlink" title="事件对象相关属性与方法"></a>事件对象相关属性与方法</h3><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">event.type</td>
<td align="left">触发的事件类型</td>
</tr>
<tr>
<td align="left">event.target</td>
<td align="left">事件的目标元素</td>
</tr>
<tr>
<td align="left">evt.clintX</td>
<td align="left">点击位置相对浏览器边界的 X 坐标</td>
</tr>
<tr>
<td align="left">evt.clintY</td>
<td align="left">点击位置相对浏览器边界的 Y 坐标</td>
</tr>
<tr>
<td align="left">evt.pageX</td>
<td align="left">点击位置相对页面边界的 X 坐标</td>
</tr>
<tr>
<td align="left">evt.pageY</td>
<td align="left">点击位置相对页面边界的 Y 坐标</td>
</tr>
<tr>
<td align="left">evt.offsetX</td>
<td align="left">相对于带有定位的父盒子的 X 坐标</td>
</tr>
<tr>
<td align="left">evt.offsetY</td>
<td align="left">相对于带有定位的父盒子的 Y 坐标</td>
</tr>
<tr>
<td align="left">evt.screenX</td>
<td align="left">点击位置相对显示器边界的 X 坐标</td>
</tr>
<tr>
<td align="left">evt.screenY</td>
<td align="left">点击位置相对显示器边界的 Y 坐标</td>
</tr>
<tr>
<td align="left">evt.keycode</td>
<td align="left">键盘按下键的键值</td>
</tr>
<tr>
<td align="left">event.preventDefault()</td>
<td align="left">阻止事件的默认动作</td>
</tr>
<tr>
<td align="left">event.stopPropagation()</td>
<td align="left">停止事件传播</td>
</tr>
</tbody></table>

            <hr>
          </div>
          <br>
          <div>
            
            <p>
              <i class="iconfont icon-tag"></i>
              
                <a class="hover-with-bg" href="/tags/DOM%20JS%20EVENT">DOM JS EVENT</a>
              
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;TOC</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>
    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/popper/popper.min.js"></script>
<script src="/lib/bootstrap/js/bootstrap.min.js"></script>
<script src="/lib/mdbootstrap/js/mdb.min.js"></script>
<script src="/js/main.js"></script>

  
    <script src="/lib/tocbot/tocbot.min.js"></script>
  
  <script src="/js/post.js"></script>


  <script src="/lib/prettify/prettify.min.js"></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint linenums');
      prettyPrint();
    })
  </script>


  <script src="/lib/typed/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "DOM&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>


  <script src="/lib/anchor/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>


</body>
</html>
